<?xml version="1.0"?>
<hml debug="yes">
<author> Gerton Lunter </author>

<alphabet id="nucleotides">
 ACGT
</alphabet>

<!--  Definition of the output "tapes"  -->
<output id="sequence1">
 <alphabet idref="nucleotides"/>
 <identifier type="length" value="iLen1"/>
 <identifier type="sequence" value="iSequence1"/>
 <!-- These identifiers need to be passed to the function, so specify them here as parameters.
      Because of the & character, we need a CDATA block to quote the text.  -->
 <code type="parameter">
  <![CDATA[
     vector<char>& iSequence1
  ]]>
 </code>
</output>
<output id="sequence2">
 <alphabet idref="nucleotides"/>
 <identifier type="length" value="iLen2"/>
 <identifier type="sequence" value="iSequence2"/>
 <code type="parameter">
  <![CDATA[
     vector<char>& iSequence2
  ]]>
 </code>
</output>

<code id="initialise1" type="statement">
  <!-- This initialisation block requires some input parameters: -->
  <code type="parameter" value="double iSigma"/>
  <!-- Actual initialisation block -->
  <![CDATA[

  int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
  int iLen2 = iSequence2.size();   // computed from the vector<char> itself

/* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
   according to a Jukes-Cantor model */

  double iEquilibriumDistribution[4];
  double iSubstitutionMatrix[4][4];
  unsigned char iTranslate[256];
  for (int i=0; i<256; i++) {
    iTranslate[i]= 0;
  }
  iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
  iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
  iTranslate[(unsigned)'C'] = 1;
  iTranslate[(unsigned)'c'] = 1;
  iTranslate[(unsigned)'G'] = 2;
  iTranslate[(unsigned)'g'] = 2;
  iTranslate[(unsigned)'T'] = 3;
  iTranslate[(unsigned)'t'] = 3;

  for (int i=0; i<4; i++) {
    iEquilibriumDistribution[i] = 1/4.0;
    for (int j=0; j<4; j++) {
      if (i==j) {
        iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
      } else {
        iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
      }
    }
  }

  ]]>
</code>

<code id="initialise2" type="statement">
  <code type="parameter"> double iEta </code>
  <![CDATA[

/* Initialisation of the iT transition-probability array. States: begin, x, silent, y, end */
  double iT[8];
  iT[0] = 1 - iEta;     // BX
  iT[1] = iEta;         // BS
  iT[2] = 1 - iEta;     // XX
  iT[3] = iEta;         // XS
  iT[4] = 1 - iEta;     // SY
  iT[5] = iEta;         // SE
  iT[6] = 1 - iEta;     // YY
  iT[7] = iEta;         // YE

  ]]>
</code>

<!--  
      Emission probabilities.  
      A number of input <identifier>s specify to which tapes this emission emits.
      An optional "output" attribute specifies the tape; when absent, the ordering of tapes in
       the defining HMM is used.
      An optional "depth" attribute specifies the lookback.  This is used for higher-order
       states.  Default is 0.  If it is used, use of the "output" attribute is required.
      Emission probabilities need not sum out to 1, e.g. when using transducers
       (conditionally normalized HMMs)
-->
<probability id="singleEmissionProb1">
  <code type="statement" init="initialise1">
    <identifier output="sequence1" value="iSymb"/>
    <identifier type="result" value="iPP"/>
    <![CDATA[
      iPP = iEquilibriumDistribution[ iTranslate[ iSymb ] ];
    ]]>
  </code>
</probability>
<probability id="singleEmissionProb2">
  <code type="statement" init="initialise1">
    <identifier output="sequence2" value="iSymb"/>
    <identifier type="result" value="iPP"/>
    <![CDATA[
      iPP = iEquilibriumDistribution[ iTranslate[ iSymb ] ];
    ]]>
  </code>
</probability>

<probability id="probBX"><code type="expression" init="initialise2"> iT[0] </code></probability>
<probability id="probBS"><code type="expression" init="initialise2"> iT[1] </code></probability>
<probability id="probXX"><code type="expression" init="initialise2"> iT[2] </code></probability>
<probability id="probXS"><code type="expression" init="initialise2"> iT[3] </code></probability>
<probability id="probSY"><code type="expression" init="initialise2"> iT[4] </code></probability>
<probability id="probSE"><code type="expression" init="initialise2"> iT[5] </code></probability>
<probability id="probYY"><code type="expression" init="initialise2"> iT[6] </code></probability>
<probability id="probYE"><code type="expression" init="initialise2"> iT[7] </code></probability>

<hmm id="Align">
 <description> random pairwise sequence aligner </description>
 <outputs id="outputs">
  <output idref="sequence1"/>
  <output idref="sequence2"/>
 </outputs>
 <clique id="block1">
  <state id="begin" emission="empty"/>
 </clique>
 <clique id="block2">
  <state id="emitx"/>
 </clique>
 <clique id="block3">
  <state id="silent"/>
 </clique>
 <clique id="block4">
  <state id="emity"/>
 </clique>
 <clique id="block5">
  <state id="end"/>
 </clique>
 <graph>
  <clique idref="block1"/>
  <clique idref="block2"/>
  <clique idref="block3"/>
  <clique idref="block4"/>
  <clique idref="block5"/>
 </graph>

  <emission id="emit1">
   <output idref="sequence1"/>
   <probability idref="singleEmissionProb1"/>
  </emission>
  <emission id="emit2">
   <output idref="sequence2"/>
   <probability idref="singleEmissionProb2"/>
  </emission>
  <emission id="empty">
   <probability><code type="expression"> 1.0 </code></probability>
  </emission>

  <!--  Define all transitions: "from" and "to" states, transition probability, and emission  
        It is permissible to assign emissions to states (see the end state).  In this case,
        all transitions going to that state should have no "emission" attribute.   
   -->
  <transitions id="transitions">
  <transition id="trBX" from="begin"  to="emitx"  probability="probBX" emission="emit1"/>
  <transition id="trBS" from="begin"  to="silent" probability="probBS" emission="empty"/>
  <transition id="trXX" from="emitx"  to="emitx"  probability="probXX" emission="emit1"/>
  <transition id="trXS" from="emitx"  to="silent" probability="probXS" emission="empty"/>
  <transition id="trSY" from="silent" to="emity"  probability="probSY" emission="emit2"/>
  <transition id="trYY" from="emity"  to="emity"  probability="probYY" emission="emit2"/>
  <transition id="trYE" from="emity"  to="end"    probability="probYE" emission="empty"/>
  </transitions>
</hmm>

<!-- Code generation -->
<forward outputTable="yes" baumWelch="no" name="Forward" id="fw">
  <hmm idref="Align"/>
</forward>
<backward outputTable="no" baumWelch="transitions" name="BackwardBaumWelch" id="bwbw">
  <hmm idref="Align"/>
</backward>
<backward outputTable="yes" baumWelch="no" name="Backward" id="bw">
  <!-- Specify HMM to make code for -->
  <hmm idref="Align"/>
</backward>
<sample name="Sample" id="smp">
  <hmm idref="Align"/>
</sample>
<viterbi name="Viterbi" id="vit">
  <hmm idref="Align"/>
</viterbi>

<codeGeneration realtype="bfloat" file="aligner.cc" header="aligner.h" language="C++">
  <forward idref="fw"/>
  <backward idref="bwbw"/>
  <backward idref="bw"/>
  <sample idref="smp"/>
  <viterbi idref="vit"/>
</codeGeneration>

</hml>
