/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file cpgislands.xml (author: Gerton Lunter) on Wed Mar 05 13:04:48 PST 2014 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/


#include "cpgislands.h"


const extern string _CpGislandstateId[];
const extern string _CpGislandemissionId[];
const extern string _CpGislandtransitionId[];
const extern string _CpGislandtransF[];
const extern string _CpGislandtransT[];
const extern string _CpGislandtransP[];
const extern string _CpGislandtransE[];
const extern string _CpGislandoutputId[];
const extern string _CpGislandempty;
const extern int _CpGislandstateNum;
const extern int _CpGislandemitNum;
const extern int _CpGislandtransNum;
const extern int _CpGislandoutputNum;

CpGislandDPTable::CpGislandDPTable(int iLen1) : isInCharge(true), stateId(_CpGislandstateId), emissionId(_CpGislandemissionId), transitionId(_CpGislandtransitionId), transitionFrom(_CpGislandtransF), transitionTo(_CpGislandtransT), transitionProb(_CpGislandtransP), transitionEmit(_CpGislandtransE), outputId(_CpGislandoutputId) {
    // init code:
    this->iLen1 = iLen1;
    StateMemoryblock2.allocate(0+iLen1);
    StateMemoryblock1.allocate();
    StateMemoryblock3.allocate();
}


CpGislandDPTable::~CpGislandDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2.absolve();
        StateMemoryblock1.absolve();
        StateMemoryblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& CpGislandDPTable::getTransitionId(int id) { return id>=0 && id<_CpGislandtransNum ? _CpGislandtransitionId[id] : _CpGislandempty; }
const string& CpGislandDPTable::getEmissionId(int id) { return id>=0 && id<_CpGislandemitNum ? _CpGislandemissionId[id] : _CpGislandempty; }
const string& CpGislandDPTable::getStateId(int id) { return id>=0 && id<_CpGislandstateNum ? _CpGislandstateId[id] : _CpGislandempty; }
const string& CpGislandDPTable::getOutputId(int id) { return id>=0 && id<_CpGislandoutputNum ? _CpGislandoutputId[id] : _CpGislandempty; }
int CpGislandDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_CpGislandstateNum;i++) {
            (*pmId)[_CpGislandstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_CpGislandemitNum; i++) {
            (*pmId)[_CpGislandemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_CpGislandtransNum; i++) {  
            (*pmId)[_CpGislandtransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_CpGislandoutputNum; i++) {
            (*pmId)[_CpGislandoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "CpGislandDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat CpGislandDPTable::getProb(const string sState ,int iPos0) const
{
    return getProb(getId(sState) ,iPos0);
}


bfloat CpGislandDPTable::getProb(int iState ,int iPos0) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=1)&&(iPos0+0<=iLen1+0)) {
            CurStateMemoryblock2Secondary = this->StateMemoryblock2.read((iPos0-(0))-(1));
            return CurStateMemoryblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

int CpGislandBaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "CpGislandBaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


int CpGislandBaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "CpGislandBaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


void CpGislandBaumWelch::resetCounts() {
    static bool bInited = false;
    if (!bInited) {
        static const int aTemp[] = {0};
        for (int i=0; i<1; i++) {
            transitionIdentifier0[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_CpGislandtransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<1; i++) {
        
        transitionBaumWelchCount0[i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {1, 2, 3, 4, 5, 6};
        for (int i=0; i<6; i++) {
            transitionIdentifier1[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_CpGislandtransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<6; i++) {
        for(int v00=0;v00<4;v00++)
        transitionBaumWelchCount1[v00][i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {0, 1};
        for (int i=0; i<2; i++) {
            emissionIdentifier1[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_CpGislandemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<2; i++) {
        for(int v00=0;v00<4;v00++)
        emissionBaumWelchCount1[v00][i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {2};
        for (int i=0; i<1; i++) {
            emissionIdentifier2[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_CpGislandemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<1; i++) {
        for(int v00=0;v00<4;v00++)for(int v01=0;v01<4;v01++)
        emissionBaumWelchCount2[v00][v01][i] = 0.0;
    }
    bInited = true;
};


int CpGislandBaumWelch::transitionIdentifier0[];
int CpGislandBaumWelch::transitionIdentifier1[];
int CpGislandBaumWelch::emissionIdentifier1[];
int CpGislandBaumWelch::emissionIdentifier2[];

void CpGislandBaumWelch::scaleCounts(bfloat scale) {
    for (int i=0; i<1; i++) {
        
        transitionBaumWelchCount0[i] *= scale;
    }
    for (int i=0; i<6; i++) {
        for(int v00=0;v00<4;v00++)
        transitionBaumWelchCount1[v00][i] *= scale;
    }
    for (int i=0; i<2; i++) {
        for(int v00=0;v00<4;v00++)
        emissionBaumWelchCount1[v00][i] *= scale;
    }
    for (int i=0; i<1; i++) {
        for(int v00=0;v00<4;v00++)for(int v01=0;v01<4;v01++)
        emissionBaumWelchCount2[v00][v01][i] *= scale;
    }
}


map<const string,int> CpGislandBaumWelch::mId;
int CpGislandBaumWelch::atransitionIdx[];
int CpGislandBaumWelch::aemissionIdx[];

bfloat hmmocMax(bfloat i, bfloat j) { return i>j ? i : j; }
void hmmocMaxInPlace(bfloat& i, bfloat j) { if (i<j) i=j; }
ostream& operator<<(ostream& os, const Path& p)
{
    for (unsigned int i=0; i<p.size(); i++) {
        os << p.fromState(i) << "--{";
            for (unsigned int j=0; j<p.emission(i).size(); j++) {
                if (j) os<<",";
                os<<p.emission(i)[j];
            }
        os<<"};"<<p.prob(i)<<"-->"<<p.toState(i)<<endl;
    }
    return os;
}

void SimplePath::addEdge(int tr, double p, vector<int>& e, int f, int t) {
    transitions.push_back(tr);
    probs.push_back(p);
    emissions.push_back(e);
    froms.push_back(f);
    tos.push_back(t);
}

void SimplePath::reverse() 
{
    std::reverse(transitions.begin(),transitions.end());
    std::reverse(probs.begin(),probs.end());
    std::reverse(emissions.begin(),emissions.end());
    std::reverse(froms.begin(),froms.end());
    std::reverse(tos.begin(),tos.end());
}

double SimplePath::prob(int i) const {
    return probs[i];
}

int SimplePath::nextFrom(int i) const {
    if (i+1 < (int)transitions.size())
    return i+1;
    else
    return -1;
}

int SimplePath::nextTo(int i) const {
    return -1;
}

const vector<int>& SimplePath::emission(int i) const {
    return emissions[i];
}

int SimplePath::fromState(int i) const {
    return froms[i];
}

int SimplePath::toState(int i) const {
    return tos[i];
}

const string _CpGislandstateId[] = {"start","normal","cpgisland","end"};
const string _CpGislandemissionId[] = {"emitcpgisland","empty","emitnormal"};
const string _CpGislandtransitionId[] = {"start-cpg","nrm-end","nrm-cpg","nrm-nrm","cpg-end","cpg-cpg","cpg-nrm"};
const string _CpGislandtransF[] = {"start","normal","normal","normal","cpgisland","cpgisland","cpgisland"};
const string _CpGislandtransT[] = {"cpgisland","end","cpgisland","normal","end","cpgisland","normal"};
const string _CpGislandtransP[] = {"full","epsilon","go","stay","epsilon","stay","go"};
const string _CpGislandtransE[] = {"emitcpgisland","empty","emitcpgisland","emitnormal","empty","emitcpgisland","emitnormal"};
const string _CpGislandoutputId[] = {"sequence1"};
const string _CpGislandempty = "";
const int _CpGislandstateNum = 4;
const int _CpGislandemitNum = 3;
const int _CpGislandtransNum = 7;
const int _CpGislandoutputNum = 1;




bfloat Forward(CpGislandDPTable** ppOutTable,char* iSequence1,double iEpsilon,double iStay,double* aEmission,int iLen1) {
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock1From;
    const bfloat *CurStateMemoryblock2From;
    bfloat *CurStateMemoryblock3To;
    const bfloat *CurStateMemoryblock3From;
    int iPrevSlowCoord;
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    CpGislandDPTable dp(iLen1);
    iTransition[0] = 1.0;
    
    iTransition[1] = iEpsilon;
    
    iTransition[2] = 1.0-iStay-iEpsilon;
    
    iTransition[3] = iStay;
    
    iTransition[4] = iEpsilon;
    
    iTransition[5] = iStay;
    
    iTransition[6] = 1.0-iStay-iEpsilon;
    dp.StateMemoryblock1.write()[0] = 1.0;
    dp.StateMemoryblock1.written();
    iPrevSlowCoord = -1;
    for (int iPos0=0; iPos0<iLen1+1; ++iPos0) {
        if ((iPos0+0<=0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+-1>=0)) {
                iSymbol[0] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-2>=0)) {
                iSymbol[1] = iSequence1[iPos0+-2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            if (iSymbol[1] != 'C') {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                } else {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[4]; break;
                    case 'T': iTempResult[0] = aEmission[5]; break;
                    case 'C': iTempResult[0] = aEmission[6]; break;
                    case 'G': iTempResult[0] = aEmission[7]; break;
                    default: cout << "Error!" << endl;
                }
            }
            iEmission[0] = iTempResult[0];
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[1] = iTempResult[0];
            if ((iPos0+-1<=0)) {
                CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To[1] = ((iTransition[0])*(iEmission[1]))*CurStateMemoryblock1From[0];
            }
            if ((iPos0+-1>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(1))-(1));
                CurStateMemoryblock2To[0] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[0] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[1];
                CurStateMemoryblock2To[1] += ((iTransition[2])*(iEmission[1]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[1] += ((iTransition[5])*(iEmission[1]))*CurStateMemoryblock2From[1];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0>=iLen1+0)) {
            if ((iPos0+-1>=0)) {
                iSymbol[0] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.write();
            iEmission[0] = 1.0;
            if ((iPos0+0>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(1));
                CurStateMemoryblock3To[0] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock3To[0] += ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
            }
            dp.StateMemoryblock3.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen1+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
        iTempProb[0] = CurStateMemoryblock3From[0];
    }
    *ppOutTable = new CpGislandDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat Backward(CpGislandBaumWelch& bw,CpGislandDPTable* pInTable,CpGislandDPTable** ppOutTable,char* iSequence1,double iEpsilon,double iStay,double* aEmission,int iLen1) {
    const bfloat *CurStateMemoryblock3Secondary;
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock2From;
    unsigned char alphaSymbolnucleotides[4] = {'A', 'C', 'G', 'T'};
    unsigned char alphaIndexnucleotides[256];
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[3];
    CpGislandDPTable dp(iLen1);
    CpGislandDPTable dp2(*pInTable);
    // make sure tables don't get deleted
    dp2.isInCharge = false;
    iTransition[0] = 1.0;
    
    iTransition[1] = iEpsilon;
    
    iTransition[2] = 1.0-iStay-iEpsilon;
    
    iTransition[3] = iStay;
    
    iTransition[4] = iEpsilon;
    
    iTransition[5] = iStay;
    
    iTransition[6] = 1.0-iStay-iEpsilon;
    for (int i=0; i<256; i++) {
        alphaIndexnucleotides[i]=0;
    }
    for (int i=0; i<4; i++) {
        alphaIndexnucleotides[alphaSymbolnucleotides[i]]=i;
    }
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen1+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3Secondary = dp2.StateMemoryblock3.read();
        iTempProb[2] = CurStateMemoryblock3Secondary[0];
        bw.scaleCounts(iTempProb[2]);
    }
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen1+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-1>=0)) {
                iSymbol[1] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            CurStateMemoryblock2Secondary = dp2.StateMemoryblock2.read((iPos0-(0))-(1));
            if (iSymbol[1] != 'C') {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                } else {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[4]; break;
                    case 'T': iTempResult[0] = aEmission[5]; break;
                    case 'C': iTempResult[0] = aEmission[6]; break;
                    case 'G': iTempResult[0] = aEmission[7]; break;
                    default: cout << "Error!" << endl;
                }
            }
            iEmission[0] = iTempResult[0];
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[1] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[0] = iTempProb[1] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][2] += iTempProb[1];
                bw.emissionBaumWelchCount2[alphaIndexnucleotides[iSymbol[1]]][alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[2])*(iEmission[1]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][1] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[1] = iTempProb[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][5] += iTempProb[1];
                bw.emissionBaumWelchCount2[alphaIndexnucleotides[iSymbol[1]]][alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[5])*(iEmission[1]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][4] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen1+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock3From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][0] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][1] += iTempProb[1];
                CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock3From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][3] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[1]]][1] += iTempProb[1];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            CurStateMemoryblock1Secondary = dp2.StateMemoryblock1.read();
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = iTempProb[1] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock1Secondary[0];
                bw.transitionBaumWelchCount0[0] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    bw.scaleCounts(1.0 / iTempProb[2]);
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new CpGislandDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& Sample(CpGislandDPTable* pInTable,char* iSequence1,double iEpsilon,double iStay,double* aEmission,int iLen1) {
    bfloat iTransition[7];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = 1.0;
    
    iTransition[1] = iEpsilon;
    
    iTransition[2] = 1.0-iStay-iEpsilon;
    
    iTransition[3] = iStay;
    
    iTransition[4] = iEpsilon;
    
    iTransition[5] = iStay;
    
    iTransition[6] = 1.0-iStay-iEpsilon;
    static const int stateTable[] = {2, 3, 2, 1, 3, 2, 1};
    static const int stateFromTable[] = {0, 1, 1, 1, 2, 2, 2};
    static const int iPos0Table[] = {1, 0, 1, 1, 0, 1, 1};
    CpGislandDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        iTempIntVec[0] = 0;
        while (iTempIntVec[0] != 3) {
            iTempIntVec[1] = 2;
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-1>=0)) {
                iSymbol[1] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.read();
            CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(1));
            if ((iPos0+1<=iLen1+0)) {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                iEmission[0] = iTempResult[0];
                if (iSymbol[1] != 'C') {
                    switch (iSymbol[0]) {
                        case 'A': iTempResult[0] = aEmission[0]; break;
                        case 'T': iTempResult[0] = aEmission[1]; break;
                        case 'C': iTempResult[0] = aEmission[2]; break;
                        case 'G': iTempResult[0] = aEmission[3]; break;
                        default: cout << "Error!" << endl;
                    }
                    } else {
                    switch (iSymbol[0]) {
                        case 'A': iTempResult[0] = aEmission[4]; break;
                        case 'T': iTempResult[0] = aEmission[5]; break;
                        case 'C': iTempResult[0] = aEmission[6]; break;
                        case 'G': iTempResult[0] = aEmission[7]; break;
                        default: cout << "Error!" << endl;
                    }
                }
                iEmission[1] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 5;
                    iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 6;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 2;
                    iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 3;
                    break;
                    case 0:
                    iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 0;
                    break;
                }
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.read();
            if ((iPos0+0>=iLen1+0)) {
                iEmission[0] = 1.0;
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 1;
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 4;
                    break;
                }
            }
            iTempVector[0] = iTempVector[1] = 0.0;
            for (int i=2; i<iTempIntVec[1]; i++) {
                iTempVector[0] += iTempVector[i];
            }
            iTempVector[0] *= (random() / (double)RAND_MAX);
            iTempIntVec[0] = 1;
            while (iTempVector[0]>=iTempVector[1] && ++iTempIntVec[0]<iTempIntVec[1]) {
                iTempVector[1] += iTempVector[iTempIntVec[0]];
            }
            if (iTempIntVec[0]==iTempIntVec[1]) {
                cerr << "Error in sampler -- zero probabilities?" << endl;
                exit(1);
            }
            emit.resize(1);
            emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
            pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
            iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
            iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
        }
    }
    return *pPath;
};





bfloat Viterbi_recurse(CpGislandDPTable** ppOutTable,char* iSequence1,double iEpsilon,double iStay,double* aEmission,int iLen1) {
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    CpGislandDPTable dp(iLen1);
    iTransition[0] = 1.0;
    
    iTransition[1] = iEpsilon;
    
    iTransition[2] = 1.0-iStay-iEpsilon;
    
    iTransition[3] = iStay;
    
    iTransition[4] = iEpsilon;
    
    iTransition[5] = iStay;
    
    iTransition[6] = 1.0-iStay-iEpsilon;
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen1+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-1>=0)) {
                iSymbol[1] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            if (iSymbol[1] != 'C') {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                } else {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[4]; break;
                    case 'T': iTempResult[0] = aEmission[5]; break;
                    case 'C': iTempResult[0] = aEmission[6]; break;
                    case 'G': iTempResult[0] = aEmission[7]; break;
                    default: cout << "Error!" << endl;
                }
            }
            iEmission[0] = iTempResult[0];
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[1] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[0] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[0];
                hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[2])*(iEmission[1]))*CurStateMemoryblock2From[1] );
                CurStateMemoryblock2To[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[0];
                hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[5])*(iEmission[1]))*CurStateMemoryblock2From[1] );
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen1+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock3From[0] );
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[1];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new CpGislandDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& Viterbi_trace(CpGislandDPTable* pInTable,char* iSequence1,double iEpsilon,double iStay,double* aEmission,int iLen1) {
    bfloat iTransition[7];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = 1.0;
    
    iTransition[1] = iEpsilon;
    
    iTransition[2] = 1.0-iStay-iEpsilon;
    
    iTransition[3] = iStay;
    
    iTransition[4] = iEpsilon;
    
    iTransition[5] = iStay;
    
    iTransition[6] = 1.0-iStay-iEpsilon;
    static const int stateTable[] = {2, 3, 2, 1, 3, 2, 1};
    static const int stateFromTable[] = {0, 1, 1, 1, 2, 2, 2};
    static const int iPos0Table[] = {1, 0, 1, 1, 0, 1, 1};
    CpGislandDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        iTempIntVec[0] = 0;
        while (iTempIntVec[0] != 3) {
            iTempIntVec[1] = 2;
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-1>=0)) {
                iSymbol[1] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.read();
            CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(1));
            if ((iPos0+1<=iLen1+0)) {
                if (iSymbol[1] != 'C') {
                    switch (iSymbol[0]) {
                        case 'A': iTempResult[0] = aEmission[0]; break;
                        case 'T': iTempResult[0] = aEmission[1]; break;
                        case 'C': iTempResult[0] = aEmission[2]; break;
                        case 'G': iTempResult[0] = aEmission[3]; break;
                        default: cout << "Error!" << endl;
                    }
                    } else {
                    switch (iSymbol[0]) {
                        case 'A': iTempResult[0] = aEmission[4]; break;
                        case 'T': iTempResult[0] = aEmission[5]; break;
                        case 'C': iTempResult[0] = aEmission[6]; break;
                        case 'G': iTempResult[0] = aEmission[7]; break;
                        default: cout << "Error!" << endl;
                    }
                }
                iEmission[0] = iTempResult[0];
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                iEmission[1] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[1]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 5;
                    iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 6;
                    break;
                    case 0:
                    iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[1]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 0;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[1]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 2;
                    iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 3;
                    break;
                }
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.read();
            if ((iPos0+0>=iLen1+0)) {
                iEmission[0] = 1.0;
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 4;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 1;
                    break;
                }
            }
            iTempVector[0] = 0.0;
            for (int i=2; i<iTempIntVec[1]; i++) {
                if (iTempVector[i]>iTempVector[0]) {
                    iTempVector[0]=iTempVector[i];
                    iTempIntVec[0] = i;
                }
            }
            emit.resize(1);
            emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
            pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
            iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
            iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
        }
    }
    return *pPath;
};



/* --- end of HMMoC-generated file --- */
