/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file genefinder.xml (author: Gerton Lunter) on Wed Mar 05 13:44:46 PST 2014 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef _genefinder_h_
#define _genefinder_h_


#include "dptables.h"
#include "algebras.h"

#include <vector>
#include <iostream>
#include <string>
#include <algorithm>

using std::vector;
using std::cout;
using std::string;

#include <map>

using std::map;

#include <stdlib.h>
#include <math.h>


// Here go the state memory clique typedefs:
typedef States<bfloat,4> Statesblock2;
typedef States<bfloat,1> Statesblock1;
typedef States<bfloat,1> Statesblock3;

class GeneFinderDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen1;
    DPTable<Statesblock2,1> StateMemoryblock2;
    DPTable<Statesblock1,0> StateMemoryblock1;
    DPTable<Statesblock3,0> StateMemoryblock3;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    GeneFinderDPTable(int iLen1);
    ~GeneFinderDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ) const;
    bfloat getProb(const string sState ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};

// give a name to the real type used for this HMM
typedef bfloat GeneFinderReal;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef double GeneFinderShortReal;



class GeneFinderBaumWelch {
    public:
    // Default copy constructor is used.
    // Void constructor:
    GeneFinderBaumWelch() { resetCounts(); }
    // Not calling resetCounts() across calls allows to aggregate results over multiple datasets
    void resetCounts();
    void scaleCounts(bfloat scale);
    // Translate an identifier (string or integer) to the index into their corresponding Baum-Welch counter array (below)
    // Which array is used for any particular emission/transition depends on its order signature - see documentation for details
    int transitionIndex(int intId) const { return atransitionIdx[intId]; }
    int transitionIndex(string strId) const;
    int emissionIndex(int intId) const { return aemissionIdx[intId]; }
    int emissionIndex(string strId) const;
    // Now follow, in triplets (one for each order signature):
    //  Transition or emission counters;
    //  Array of identifiers; and
    //  Dimension of array (number of counters).
    bfloat transitionBaumWelchCount0[8];
    static int transitionIdentifier0[8];   
    static const int transitionDimension0 = 8;
    bfloat emissionBaumWelchCount0[1];
    static int emissionIdentifier0[1];   
    static const int emissionDimension0 = 1;
    bfloat emissionBaumWelchCount1[4][1];
    static int emissionIdentifier1[1];   
    static const int emissionDimension1 = 1;
    bfloat emissionBaumWelchCount3[4][4][4][3];
    static int emissionIdentifier3[3];   
    static const int emissionDimension3 = 3;
    private:
    static int atransitionIdx[8];
    static int aemissionIdx[5];
    static map<const string,int> mId;
};




#ifndef _PATH_CLASS_DEFINED_
#define _PATH_CLASS_DEFINED_

class Path {
    //protected:
    public:
    vector<int> transitions;
    public:
    unsigned int size() const {                             // Number of transitions in path
        return transitions.size(); 
    }
    int transition(int i) const {                           // i-th transition
        return transitions[i]; 
    }
    virtual double prob(int) const = 0;                  // i-th transition*emission probability:
    virtual const vector<int>& emission(int) const = 0;  // i-th emission vector
    virtual int fromState(int) const = 0;                // State at from-end of i-th transition
    virtual int toState(int) const = 0;                  // State at to-end of i-th transition
    virtual int nextFrom(int) const = 0;                 // index of next sibling, -1 if no more (always -1 for simple paths)
    virtual int nextTo(int) const = 0;                   // index of child (always i+1 for simple paths), or -1 if no more
    virtual ~Path() {} 
};

ostream& operator<<(ostream& os, const Path& p);

class SimplePath: public Path {
    public:
    vector<double> probs;
    vector<vector<int> > emissions;
    vector<int> froms;
    vector<int> tos;
    public:
    void addEdge(int transition, double prob, vector<int>& emission, int from, int to);
    double prob(int index) const;
    int nextFrom(int index) const;
    int nextTo(int index) const;
    const vector<int>& emission(int index) const;
    int fromState(int index) const;
    int toState(int index) const;
    void reverse();
};  

#endif // _PATH_CLASS_DEFINED_

bfloat Forward(GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1);

bfloat Backward(GeneFinderBaumWelch& bw,GeneFinderDPTable* pInTable,GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1);

Path& Sample(GeneFinderDPTable* pInTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1);

bfloat Viterbi_recurse(GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1);

Path& Viterbi_trace(GeneFinderDPTable* pInTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1);

#endif // _genefinder_h_

/* --- end of HMMoC-generated file --- */
