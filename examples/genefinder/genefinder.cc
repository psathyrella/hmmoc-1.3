/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file genefinder.xml (author: Gerton Lunter) on Wed Mar 05 13:44:46 PST 2014 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/


#include "genefinder.h"


const extern string _GeneFinderstateId[];
const extern string _GeneFinderemissionId[];
const extern string _GeneFindertransitionId[];
const extern string _GeneFindertransF[];
const extern string _GeneFindertransT[];
const extern string _GeneFindertransP[];
const extern string _GeneFindertransE[];
const extern string _GeneFinderoutputId[];
const extern string _GeneFinderempty;
const extern int _GeneFinderstateNum;
const extern int _GeneFinderemitNum;
const extern int _GeneFindertransNum;
const extern int _GeneFinderoutputNum;

GeneFinderDPTable::GeneFinderDPTable(int iLen1) : isInCharge(true), stateId(_GeneFinderstateId), emissionId(_GeneFinderemissionId), transitionId(_GeneFindertransitionId), transitionFrom(_GeneFindertransF), transitionTo(_GeneFindertransT), transitionProb(_GeneFindertransP), transitionEmit(_GeneFindertransE), outputId(_GeneFinderoutputId) {
    // init code:
    this->iLen1 = iLen1;
    StateMemoryblock2.allocate(0+iLen1);
    StateMemoryblock1.allocate();
    StateMemoryblock3.allocate();
}


GeneFinderDPTable::~GeneFinderDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2.absolve();
        StateMemoryblock1.absolve();
        StateMemoryblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& GeneFinderDPTable::getTransitionId(int id) { return id>=0 && id<_GeneFindertransNum ? _GeneFindertransitionId[id] : _GeneFinderempty; }
const string& GeneFinderDPTable::getEmissionId(int id) { return id>=0 && id<_GeneFinderemitNum ? _GeneFinderemissionId[id] : _GeneFinderempty; }
const string& GeneFinderDPTable::getStateId(int id) { return id>=0 && id<_GeneFinderstateNum ? _GeneFinderstateId[id] : _GeneFinderempty; }
const string& GeneFinderDPTable::getOutputId(int id) { return id>=0 && id<_GeneFinderoutputNum ? _GeneFinderoutputId[id] : _GeneFinderempty; }
int GeneFinderDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_GeneFinderstateNum;i++) {
            (*pmId)[_GeneFinderstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_GeneFinderemitNum; i++) {
            (*pmId)[_GeneFinderemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_GeneFindertransNum; i++) {  
            (*pmId)[_GeneFindertransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_GeneFinderoutputNum; i++) {
            (*pmId)[_GeneFinderoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "GeneFinderDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat GeneFinderDPTable::getProb(const string sState ,int iPos0) const
{
    return getProb(getId(sState) ,iPos0);
}


bfloat GeneFinderDPTable::getProb(int iState ,int iPos0) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 2, 3, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=1)&&(iPos0+0<=iLen1+0)) {
            CurStateMemoryblock2Secondary = this->StateMemoryblock2.read((iPos0-(0))-(1));
            return CurStateMemoryblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

int GeneFinderBaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "GeneFinderBaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


int GeneFinderBaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "GeneFinderBaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


void GeneFinderBaumWelch::resetCounts() {
    static bool bInited = false;
    if (!bInited) {
        static const int aTemp[] = {0, 1, 2, 3, 4, 5, 6, 7};
        for (int i=0; i<8; i++) {
            transitionIdentifier0[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_GeneFindertransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<8; i++) {
        
        transitionBaumWelchCount0[i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {0};
        for (int i=0; i<1; i++) {
            emissionIdentifier0[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_GeneFinderemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<1; i++) {
        
        emissionBaumWelchCount0[i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {4};
        for (int i=0; i<1; i++) {
            emissionIdentifier1[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_GeneFinderemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<1; i++) {
        for(int v00=0;v00<4;v00++)
        emissionBaumWelchCount1[v00][i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {1, 2, 3};
        for (int i=0; i<3; i++) {
            emissionIdentifier3[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_GeneFinderemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<3; i++) {
        for(int v00=0;v00<4;v00++)for(int v01=0;v01<4;v01++)for(int v02=0;v02<4;v02++)
        emissionBaumWelchCount3[v00][v01][v02][i] = 0.0;
    }
    bInited = true;
};


int GeneFinderBaumWelch::transitionIdentifier0[];
int GeneFinderBaumWelch::emissionIdentifier0[];
int GeneFinderBaumWelch::emissionIdentifier1[];
int GeneFinderBaumWelch::emissionIdentifier3[];

void GeneFinderBaumWelch::scaleCounts(bfloat scale) {
    for (int i=0; i<8; i++) {
        
        transitionBaumWelchCount0[i] *= scale;
    }
    for (int i=0; i<1; i++) {
        
        emissionBaumWelchCount0[i] *= scale;
    }
    for (int i=0; i<1; i++) {
        for(int v00=0;v00<4;v00++)
        emissionBaumWelchCount1[v00][i] *= scale;
    }
    for (int i=0; i<3; i++) {
        for(int v00=0;v00<4;v00++)for(int v01=0;v01<4;v01++)for(int v02=0;v02<4;v02++)
        emissionBaumWelchCount3[v00][v01][v02][i] *= scale;
    }
}


map<const string,int> GeneFinderBaumWelch::mId;
int GeneFinderBaumWelch::atransitionIdx[];
int GeneFinderBaumWelch::aemissionIdx[];

bfloat hmmocMax(bfloat i, bfloat j) { return i>j ? i : j; }
void hmmocMaxInPlace(bfloat& i, bfloat j) { if (i<j) i=j; }
ostream& operator<<(ostream& os, const Path& p)
{
    for (unsigned int i=0; i<p.size(); i++) {
        os << p.fromState(i) << "--{";
            for (unsigned int j=0; j<p.emission(i).size(); j++) {
                if (j) os<<",";
                os<<p.emission(i)[j];
            }
        os<<"};"<<p.prob(i)<<"-->"<<p.toState(i)<<endl;
    }
    return os;
}

void SimplePath::addEdge(int tr, double p, vector<int>& e, int f, int t) {
    transitions.push_back(tr);
    probs.push_back(p);
    emissions.push_back(e);
    froms.push_back(f);
    tos.push_back(t);
}

void SimplePath::reverse() 
{
    std::reverse(transitions.begin(),transitions.end());
    std::reverse(probs.begin(),probs.end());
    std::reverse(emissions.begin(),emissions.end());
    std::reverse(froms.begin(),froms.end());
    std::reverse(tos.begin(),tos.end());
}

double SimplePath::prob(int i) const {
    return probs[i];
}

int SimplePath::nextFrom(int i) const {
    if (i+1 < (int)transitions.size())
    return i+1;
    else
    return -1;
}

int SimplePath::nextTo(int i) const {
    return -1;
}

const vector<int>& SimplePath::emission(int i) const {
    return emissions[i];
}

int SimplePath::fromState(int i) const {
    return froms[i];
}

int SimplePath::toState(int i) const {
    return tos[i];
}

const string _GeneFinderstateId[] = {"start","gene","startcodon","background","stop","end"};
const string _GeneFinderemissionId[] = {"empty","emitstop","emitcodon","emitstart","emitbackground"};
const string _GeneFindertransitionId[] = {"start-bg","bg-bg","bg-start","bg-end","start-gene","gene-gene","gene-stop","stop-bg"};
const string _GeneFindertransF[] = {"start","background","background","background","startcodon","gene","gene","stop"};
const string _GeneFindertransT[] = {"background","background","startcodon","end","gene","gene","stop","background"};
const string _GeneFindertransP[] = {"full","bgbg","bgstart","bgend","full","extend","genestop","full"};
const string _GeneFindertransE[] = {"emitbackground","emitbackground","emitstart","empty","emitcodon","emitcodon","emitstop","emitbackground"};
const string _GeneFinderoutputId[] = {"sequence1"};
const string _GeneFinderempty = "";
const int _GeneFinderstateNum = 6;
const int _GeneFinderemitNum = 5;
const int _GeneFindertransNum = 8;
const int _GeneFinderoutputNum = 1;




bfloat Forward(GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1) {
    bfloat iTransition[8];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock1From;
    const bfloat *CurStateMemoryblock2From;
    bfloat *CurStateMemoryblock3To;
    const bfloat *CurStateMemoryblock3From;
    int iPrevSlowCoord;
    int iSymbol[3];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[3];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    GeneFinderDPTable dp(iLen1);
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0-0.0001-iGeneDensity;
    
    iTransition[2] = iGeneDensity;
    
    iTransition[3] = 0.0001;
    
    iTransition[4] = 1.0;
    
    iTransition[5] = 1.0-1.0/iGeneLength;
    
    iTransition[6] = 1.0/iGeneLength;
    
    iTransition[7] = 1.0;
    dp.StateMemoryblock1.write()[0] = 1.0;
    dp.StateMemoryblock1.written();
    iPrevSlowCoord = -1;
    for (int iPos0=0; iPos0<iLen1+1; ++iPos0) {
        if ((iPos0+0<=0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+-1>=0)) {
                iSymbol[0] = iSequence1[iPos0+-1];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-2>=0)) {
                iSymbol[1] = iSequence1[iPos0+-2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            if ((iPos0+-3>=0)) {
                iSymbol[2] = iSequence1[iPos0+-3];
            } 
            else { 
                iSymbol[2] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+-1<=0)) {
                CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To[2] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock1From[0];
            }
            if ((iPos0+-1>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(1))-(1));
                CurStateMemoryblock2To[2] += ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[2];
                CurStateMemoryblock2To[2] += ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock2From[3];
            }
            // anything but Stop
            if ((iSymbol[2] == 'T')&&((iSymbol[1] == 'G' && iSymbol[0] == 'A') ||
            (iSymbol[1] == 'A' && (iSymbol[0] == 'A' || iSymbol[0] == 'G'))))
            iTempResult[0] = 0.0;
            else
            iTempResult[0] = 1.0/61.0;
            iEmission[0] = iTempResult[0];
            // TGA, TAA or TAG
            if ((iSymbol[2] == 'T')&&((iSymbol[1] == 'G' && iSymbol[0] == 'A') ||
            (iSymbol[1] == 'A' && (iSymbol[0] == 'A' || iSymbol[0] == 'G'))))
            iTempResult[0] = 1.0/3.0;
            else
            iTempResult[0] = 0.0;
            iEmission[1] = iTempResult[0];
            if (iSymbol[2] == 'A' && iSymbol[1] == 'T' && iSymbol[0] == 'G')
            iTempResult[0] = 1.0;
            else
            iTempResult[0] = 0.0;
            iEmission[2] = iTempResult[0];
            if ((iPos0+-3>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(3))-(1));
                CurStateMemoryblock2To[0] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[0] += ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                CurStateMemoryblock2To[3] = ((iTransition[6])*(iEmission[1]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[1] = ((iTransition[2])*(iEmission[2]))*CurStateMemoryblock2From[2];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0>=iLen1+0)) {
            CurStateMemoryblock3To = dp.StateMemoryblock3.write();
            iEmission[0] = 1.0;
            if ((iPos0+0>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(1));
                CurStateMemoryblock3To[0] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[2];
            }
            dp.StateMemoryblock3.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen1+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
        iTempProb[0] = CurStateMemoryblock3From[0];
    }
    *ppOutTable = new GeneFinderDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat Backward(GeneFinderBaumWelch& bw,GeneFinderDPTable* pInTable,GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1) {
    const bfloat *CurStateMemoryblock3Secondary;
    bfloat iTransition[8];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock2From;
    unsigned char alphaSymbolnucleotides[4] = {'A', 'C', 'G', 'T'};
    unsigned char alphaIndexnucleotides[256];
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[3];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[3];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[3];
    GeneFinderDPTable dp(iLen1);
    GeneFinderDPTable dp2(*pInTable);
    // make sure tables don't get deleted
    dp2.isInCharge = false;
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0-0.0001-iGeneDensity;
    
    iTransition[2] = iGeneDensity;
    
    iTransition[3] = 0.0001;
    
    iTransition[4] = 1.0;
    
    iTransition[5] = 1.0-1.0/iGeneLength;
    
    iTransition[6] = 1.0/iGeneLength;
    
    iTransition[7] = 1.0;
    for (int i=0; i<256; i++) {
        alphaIndexnucleotides[i]=0;
    }
    for (int i=0; i<4; i++) {
        alphaIndexnucleotides[alphaSymbolnucleotides[i]]=i;
    }
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen1+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3Secondary = dp2.StateMemoryblock3.read();
        iTempProb[2] = CurStateMemoryblock3Secondary[0];
        bw.scaleCounts(iTempProb[2]);
    }
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen1+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+2<=iLen1+-1)) {
                iSymbol[1] = iSequence1[iPos0+2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            if ((iPos0+1<=iLen1+-1)) {
                iSymbol[2] = iSequence1[iPos0+1];
            } 
            else { 
                iSymbol[2] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            CurStateMemoryblock2Secondary = dp2.StateMemoryblock2.read((iPos0-(0))-(1));
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[3] = iTempProb[1] = ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock2From[2];
                iTempProb[1] *= CurStateMemoryblock2Secondary[3];
                bw.transitionBaumWelchCount0[7] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[2] = iTempProb[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[2];
                iTempProb[1] *= CurStateMemoryblock2Secondary[2];
                bw.transitionBaumWelchCount0[1] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
            }
            // TGA, TAA or TAG
            if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
            (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
            iTempResult[0] = 1.0/3.0;
            else
            iTempResult[0] = 0.0;
            iEmission[0] = iTempResult[0];
            // anything but Stop
            if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
            (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
            iTempResult[0] = 0.0;
            else
            iTempResult[0] = 1.0/61.0;
            iEmission[1] = iTempResult[0];
            if (iSymbol[0] == 'A' && iSymbol[2] == 'T' && iSymbol[1] == 'G')
            iTempResult[0] = 1.0;
            else
            iTempResult[0] = 0.0;
            iEmission[2] = iTempResult[0];
            if ((iPos0+3<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-3))-(1));
                CurStateMemoryblock2To[0] = iTempProb[1] = ((iTransition[5])*(iEmission[1]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount0[5] += iTempProb[1];
                bw.emissionBaumWelchCount3[alphaIndexnucleotides[iSymbol[0]]][alphaIndexnucleotides[iSymbol[2]]][alphaIndexnucleotides[iSymbol[1]]][1] += iTempProb[1];
                CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[3];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount0[6] += iTempProb[1];
                bw.emissionBaumWelchCount3[alphaIndexnucleotides[iSymbol[0]]][alphaIndexnucleotides[iSymbol[2]]][alphaIndexnucleotides[iSymbol[1]]][0] += iTempProb[1];
                CurStateMemoryblock2To[2] += iTempProb[1] = ((iTransition[2])*(iEmission[2]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock2Secondary[2];
                bw.transitionBaumWelchCount0[2] += iTempProb[1];
                bw.emissionBaumWelchCount3[alphaIndexnucleotides[iSymbol[0]]][alphaIndexnucleotides[iSymbol[2]]][alphaIndexnucleotides[iSymbol[1]]][2] += iTempProb[1];
                CurStateMemoryblock2To[1] = iTempProb[1] = ((iTransition[4])*(iEmission[1]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount0[4] += iTempProb[1];
                bw.emissionBaumWelchCount3[alphaIndexnucleotides[iSymbol[0]]][alphaIndexnucleotides[iSymbol[2]]][alphaIndexnucleotides[iSymbol[1]]][1] += iTempProb[1];
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen1+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                CurStateMemoryblock2To[2] += iTempProb[1] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock3From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[2];
                bw.transitionBaumWelchCount0[3] += iTempProb[1];
                bw.emissionBaumWelchCount0[0] += iTempProb[1];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            CurStateMemoryblock1Secondary = dp2.StateMemoryblock1.read();
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = iTempProb[1] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[2];
                iTempProb[1] *= CurStateMemoryblock1Secondary[0];
                bw.transitionBaumWelchCount0[0] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexnucleotides[iSymbol[0]]][0] += iTempProb[1];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    bw.scaleCounts(1.0 / iTempProb[2]);
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new GeneFinderDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& Sample(GeneFinderDPTable* pInTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1) {
    bfloat iTransition[8];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[3];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[3];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0-0.0001-iGeneDensity;
    
    iTransition[2] = iGeneDensity;
    
    iTransition[3] = 0.0001;
    
    iTransition[4] = 1.0;
    
    iTransition[5] = 1.0-1.0/iGeneLength;
    
    iTransition[6] = 1.0/iGeneLength;
    
    iTransition[7] = 1.0;
    static const int stateTable[] = {3, 3, 2, 5, 1, 1, 4, 3};
    static const int stateFromTable[] = {0, 3, 3, 3, 2, 1, 1, 4};
    static const int iPos0Table[] = {1, 1, 3, 0, 3, 3, 3, 1};
    GeneFinderDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        iTempIntVec[0] = 0;
        while (iTempIntVec[0] != 5) {
            iTempIntVec[1] = 2;
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+2<=iLen1+-1)) {
                iSymbol[1] = iSequence1[iPos0+2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            if ((iPos0+1<=iLen1+-1)) {
                iSymbol[2] = iSequence1[iPos0+1];
            } 
            else { 
                iSymbol[2] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.read();
            CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(1));
            if ((iPos0+1<=iLen1+0)) {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                iEmission[0] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 4:
                    iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[7]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 7;
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 1;
                    break;
                    case 0:
                    iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 0;
                    break;
                }
            }
            if ((iPos0+3<=iLen1+0)) {
                if (iSymbol[0] == 'A' && iSymbol[2] == 'T' && iSymbol[1] == 'G')
                iTempResult[0] = 1.0;
                else
                iTempResult[0] = 0.0;
                iEmission[0] = iTempResult[0];
                // anything but Stop
                if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
                (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
                iTempResult[0] = 0.0;
                else
                iTempResult[0] = 1.0/61.0;
                iEmission[1] = iTempResult[0];
                // TGA, TAA or TAG
                if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
                (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
                iTempResult[0] = 1.0/3.0;
                else
                iTempResult[0] = 0.0;
                iEmission[2] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-3))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 2;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[2]*CurStateMemoryblock2To[3];
                    iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[2];
                    iTempIntVec[iTempIntVec[1]++] = 6;
                    iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 5;
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 4;
                    break;
                }
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.read();
            if ((iPos0+0>=iLen1+0)) {
                iEmission[0] = 1.0;
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 3;
                    break;
                }
            }
            iTempVector[0] = iTempVector[1] = 0.0;
            for (int i=2; i<iTempIntVec[1]; i++) {
                iTempVector[0] += iTempVector[i];
            }
            iTempVector[0] *= (random() / (double)RAND_MAX);
            iTempIntVec[0] = 1;
            while (iTempVector[0]>=iTempVector[1] && ++iTempIntVec[0]<iTempIntVec[1]) {
                iTempVector[1] += iTempVector[iTempIntVec[0]];
            }
            if (iTempIntVec[0]==iTempIntVec[1]) {
                cerr << "Error in sampler -- zero probabilities?" << endl;
                exit(1);
            }
            emit.resize(1);
            emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
            pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
            iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
            iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
        }
    }
    return *pPath;
};





bfloat Viterbi_recurse(GeneFinderDPTable** ppOutTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1) {
    bfloat iTransition[8];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[3];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[3];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    GeneFinderDPTable dp(iLen1);
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0-0.0001-iGeneDensity;
    
    iTransition[2] = iGeneDensity;
    
    iTransition[3] = 0.0001;
    
    iTransition[4] = 1.0;
    
    iTransition[5] = 1.0-1.0/iGeneLength;
    
    iTransition[6] = 1.0/iGeneLength;
    
    iTransition[7] = 1.0;
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen1+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+2<=iLen1+-1)) {
                iSymbol[1] = iSequence1[iPos0+2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            if ((iPos0+1<=iLen1+-1)) {
                iSymbol[2] = iSequence1[iPos0+1];
            } 
            else { 
                iSymbol[2] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[3] = ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock2From[2];
                CurStateMemoryblock2To[2] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[2];
            }
            // anything but Stop
            if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
            (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
            iTempResult[0] = 0.0;
            else
            iTempResult[0] = 1.0/61.0;
            iEmission[0] = iTempResult[0];
            // TGA, TAA or TAG
            if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
            (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
            iTempResult[0] = 1.0/3.0;
            else
            iTempResult[0] = 0.0;
            iEmission[1] = iTempResult[0];
            if (iSymbol[0] == 'A' && iSymbol[2] == 'T' && iSymbol[1] == 'G')
            iTempResult[0] = 1.0;
            else
            iTempResult[0] = 0.0;
            iEmission[2] = iTempResult[0];
            if ((iPos0+3<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-3))-(1));
                CurStateMemoryblock2To[0] = ((iTransition[6])*(iEmission[1]))*CurStateMemoryblock2From[3];
                hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0] );
                hmmocMaxInPlace( CurStateMemoryblock2To[2], ((iTransition[2])*(iEmission[2]))*CurStateMemoryblock2From[1] );
                CurStateMemoryblock2To[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[0];
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen1+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                hmmocMaxInPlace( CurStateMemoryblock2To[2], ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock3From[0] );
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            switch (iSymbol[0]) {
                case 'A': iTempResult[0] = aEmission[0]; break;
                case 'T': iTempResult[0] = aEmission[1]; break;
                case 'C': iTempResult[0] = aEmission[2]; break;
                case 'G': iTempResult[0] = aEmission[3]; break;
                default: cout << "Error!" << endl;
            }
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen1+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[2];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new GeneFinderDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& Viterbi_trace(GeneFinderDPTable* pInTable,const char* iSequence1,double iGeneDensity,double iGeneLength,double* aEmission,int iLen1) {
    bfloat iTransition[8];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[3];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[3];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0-0.0001-iGeneDensity;
    
    iTransition[2] = iGeneDensity;
    
    iTransition[3] = 0.0001;
    
    iTransition[4] = 1.0;
    
    iTransition[5] = 1.0-1.0/iGeneLength;
    
    iTransition[6] = 1.0/iGeneLength;
    
    iTransition[7] = 1.0;
    static const int stateTable[] = {3, 3, 2, 5, 1, 1, 4, 3};
    static const int stateFromTable[] = {0, 3, 3, 3, 2, 1, 1, 4};
    static const int iPos0Table[] = {1, 1, 3, 0, 3, 3, 3, 1};
    GeneFinderDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        iTempIntVec[0] = 0;
        while (iTempIntVec[0] != 5) {
            iTempIntVec[1] = 2;
            if ((iPos0+0<=iLen1+-1)) {
                iSymbol[0] = iSequence1[iPos0+0];
            } 
            else { 
                iSymbol[0] = 'A' /* dummy value */;
                
            }
            if ((iPos0+2<=iLen1+-1)) {
                iSymbol[1] = iSequence1[iPos0+2];
            } 
            else { 
                iSymbol[1] = 'A' /* dummy value */;
                
            }
            if ((iPos0+1<=iLen1+-1)) {
                iSymbol[2] = iSequence1[iPos0+1];
            } 
            else { 
                iSymbol[2] = 'A' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.read();
            CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(1));
            if ((iPos0+1<=iLen1+0)) {
                switch (iSymbol[0]) {
                    case 'A': iTempResult[0] = aEmission[0]; break;
                    case 'T': iTempResult[0] = aEmission[1]; break;
                    case 'C': iTempResult[0] = aEmission[2]; break;
                    case 'G': iTempResult[0] = aEmission[3]; break;
                    default: cout << "Error!" << endl;
                }
                iEmission[0] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 4:
                    iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[7]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 7;
                    break;
                    case 0:
                    iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 0;
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2To[2];
                    iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 1;
                    break;
                }
            }
            if ((iPos0+3<=iLen1+0)) {
                // anything but Stop
                if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
                (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
                iTempResult[0] = 0.0;
                else
                iTempResult[0] = 1.0/61.0;
                iEmission[0] = iTempResult[0];
                // TGA, TAA or TAG
                if ((iSymbol[0] == 'T')&&((iSymbol[2] == 'G' && iSymbol[1] == 'A') ||
                (iSymbol[2] == 'A' && (iSymbol[1] == 'A' || iSymbol[1] == 'G'))))
                iTempResult[0] = 1.0/3.0;
                else
                iTempResult[0] = 0.0;
                iEmission[1] = iTempResult[0];
                if (iSymbol[0] == 'A' && iSymbol[2] == 'T' && iSymbol[1] == 'G')
                iTempResult[0] = 1.0;
                else
                iTempResult[0] = 0.0;
                iEmission[2] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-3))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 4;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[1]*CurStateMemoryblock2To[3];
                    iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 6;
                    iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 5;
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[2]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[2];
                    iTempIntVec[iTempIntVec[1]++] = 2;
                    break;
                }
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.read();
            if ((iPos0+0>=iLen1+0)) {
                iEmission[0] = 1.0;
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 3:
                    iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 3;
                    break;
                }
            }
            iTempVector[0] = 0.0;
            for (int i=2; i<iTempIntVec[1]; i++) {
                if (iTempVector[i]>iTempVector[0]) {
                    iTempVector[0]=iTempVector[i];
                    iTempIntVec[0] = i;
                }
            }
            emit.resize(1);
            emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
            pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
            iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
            iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
        }
    }
    return *pPath;
};



/* --- end of HMMoC-generated file --- */
