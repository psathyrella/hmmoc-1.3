/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file casino.xml (author: <unknown>) on Fri Mar 07 15:08:28 PST 2014 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef _casino_h_
#define _casino_h_


#include "dptables.h"
#include "algebras.h"

#include <vector>
#include <iostream>
#include <string>
#include <algorithm>

using std::vector;
using std::cout;
using std::string;

#include <map>

using std::map;

#include <stdlib.h>
#include <math.h>


// Here go the state memory clique typedefs:
typedef States<bfloat,2> Statesblock2;
typedef States<bfloat,1> Statesblock1;
typedef States<bfloat,1> Statesblock3;

class CasinoDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen;
    DPTable<Statesblock2,1> StateMemoryblock2;
    DPTable<Statesblock1,0> StateMemoryblock1;
    DPTable<Statesblock3,0> StateMemoryblock3;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    CasinoDPTable(int iLen);
    ~CasinoDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ) const;
    bfloat getProb(const string sState ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};

// give a name to the real type used for this HMM
typedef bfloat CasinoReal;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef double CasinoShortReal;



class CasinoBaumWelch {
    public:
    // Default copy constructor is used.
    // Void constructor:
    CasinoBaumWelch() { resetCounts(); }
    // Not calling resetCounts() across calls allows to aggregate results over multiple datasets
    void resetCounts();
    void scaleCounts(bfloat scale);
    // Translate an identifier (string or integer) to the index into their corresponding Baum-Welch counter array (below)
    // Which array is used for any particular emission/transition depends on its order signature - see documentation for details
    int transitionIndex(int intId) const { return atransitionIdx[intId]; }
    int transitionIndex(string strId) const;
    int emissionIndex(int intId) const { return aemissionIdx[intId]; }
    int emissionIndex(string strId) const;
    // Now follow, in triplets (one for each order signature):
    //  Transition or emission counters;
    //  Array of identifiers; and
    //  Dimension of array (number of counters).
    bfloat transitionBaumWelchCount0[7];
    static int transitionIdentifier0[7];   
    static const int transitionDimension0 = 7;
    bfloat emissionBaumWelchCount0[1];
    static int emissionIdentifier0[1];   
    static const int emissionDimension0 = 1;
    bfloat emissionBaumWelchCount1[6][2];
    static int emissionIdentifier1[2];   
    static const int emissionDimension1 = 2;
    private:
    static int atransitionIdx[7];
    static int aemissionIdx[3];
    static map<const string,int> mId;
};





// Here go the state memory clique typedefs:
typedef States<bfloat,1> StatesNEblock1;
typedef States<bfloat,2> StatesNEblock2;
typedef States<bfloat,1> StatesNEblock3;

class NoEmissionCasinoDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    DPTable<StatesNEblock1,0> StateMemoryNEblock1;
    DPTable<StatesNEblock2,0> StateMemoryNEblock2;
    DPTable<StatesNEblock3,0> StateMemoryNEblock3;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    NoEmissionCasinoDPTable();
    ~NoEmissionCasinoDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ) const;
    bfloat getProb(const string sState ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};

// give a name to the real type used for this HMM
typedef bfloat NoEmissionCasinoReal;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef double NoEmissionCasinoShortReal;


#ifndef _PATH_CLASS_DEFINED_
#define _PATH_CLASS_DEFINED_

class Path {
    //protected:
    public:
    vector<int> transitions;
    public:
    unsigned int size() const {                             // Number of transitions in path
        return transitions.size(); 
    }
    int transition(int i) const {                           // i-th transition
        return transitions[i]; 
    }
    virtual double prob(int) const = 0;                  // i-th transition*emission probability:
    virtual const vector<int>& emission(int) const = 0;  // i-th emission vector
    virtual int fromState(int) const = 0;                // State at from-end of i-th transition
    virtual int toState(int) const = 0;                  // State at to-end of i-th transition
    virtual int nextFrom(int) const = 0;                 // index of next sibling, -1 if no more (always -1 for simple paths)
    virtual int nextTo(int) const = 0;                   // index of child (always i+1 for simple paths), or -1 if no more
    virtual ~Path() {} 
};

ostream& operator<<(ostream& os, const Path& p);

class SimplePath: public Path {
    public:
    vector<double> probs;
    vector<vector<int> > emissions;
    vector<int> froms;
    vector<int> tos;
    public:
    void addEdge(int transition, double prob, vector<int>& emission, int from, int to);
    double prob(int index) const;
    int nextFrom(int index) const;
    int nextTo(int index) const;
    const vector<int>& emission(int index) const;
    int fromState(int index) const;
    int toState(int index) const;
    void reverse();
};  

#endif // _PATH_CLASS_DEFINED_
struct Params {
    double iGoHonest;
    double iGoDishonest;
    double iGoStop;
    double aEmitDishonest[6];
};

bfloat Forward(CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen);

bfloat Backward(CasinoBaumWelch& bw,CasinoDPTable* pInTable,CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen);

bfloat Viterbi_recurse(CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen);

Path& Viterbi_trace(CasinoDPTable* pInTable,Params iPar,char *aSeq,int iLen);

Path& NESample(NoEmissionCasinoDPTable* pInTable,Params iPar);

bfloat NEBackward(NoEmissionCasinoDPTable** ppOutTable,Params iPar);



#ifndef _HMMOCMATRIX_CLASS_DEFINED_
#define _HMMOCMATRIX_CLASS_DEFINED_

class hmmocMatrix {
    protected:
    vector<double> ivCoeff;
    public:
    int iDim;
    public:
    // Default, empty matrix
    hmmocMatrix() {
        iDim = 0;
        ivCoeff.resize(0);
    }
    // Create matrix
    hmmocMatrix( int iDimen ) {
        iDim = iDimen;
        ivCoeff.resize( iDim*iDim );
    }
    // Unit matrix init
    void unitMatrix() {
        for (int i=0; i<iDim; i++)
        for (int j=0; j<iDim; j++)
        (*this)(i,j) = (i==j);
    }
    // Copy matrix constructor
    hmmocMatrix( const hmmocMatrix& iM ) {
        this->assign( iM );
    }
    inline hmmocMatrix& assign( const hmmocMatrix& iM ) {
        iDim = iM.iDim;
        ivCoeff.resize( iDim*iDim );
        for (int i=0; i<iDim*iDim; i++) {
            ivCoeff[i] = iM.ivCoeff[i];
        }
        return *this;
    }
    inline double operator()(const int i, const int j) const { 
        if ((i<0)||(j<0)||(i>=iDim)||(j>=iDim)) {
            cerr << "hmmocMatrix::operator(): Out of range!" << endl;
            exit(1);
        } 
        return ivCoeff[i*iDim+j]; 
    }
    inline double& operator()(const int i, const int j) { 
        if ((i<0)||(j<0)||(i>=iDim)||(j>=iDim)) {
            cerr << "hmmocMatrix::operator(): Out of range!" << endl;
            exit(1);
        } 
        return ivCoeff[i*iDim+j]; 
    }
};

#endif // _HMMOCMATRIX_CLASS_DEFINED_

#endif // _casino_h_

/* --- end of HMMoC-generated file --- */
