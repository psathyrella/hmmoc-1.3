/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file casino.xml (author: Gerton Lunter) on Thu Mar 06 18:09:39 PST 2014 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/


#include "casino.h"


const extern string _CasinostateId[];
const extern string _CasinoemissionId[];
const extern string _CasinotransitionId[];
const extern string _CasinotransF[];
const extern string _CasinotransT[];
const extern string _CasinotransP[];
const extern string _CasinotransE[];
const extern string _CasinooutputId[];
const extern string _Casinoempty;
const extern int _CasinostateNum;
const extern int _CasinoemitNum;
const extern int _CasinotransNum;
const extern int _CasinooutputNum;

CasinoDPTable::CasinoDPTable(int iLen) : isInCharge(true), stateId(_CasinostateId), emissionId(_CasinoemissionId), transitionId(_CasinotransitionId), transitionFrom(_CasinotransF), transitionTo(_CasinotransT), transitionProb(_CasinotransP), transitionEmit(_CasinotransE), outputId(_CasinooutputId) {
    // init code:
    this->iLen = iLen;
    StateMemoryblock2.allocate(0+iLen);
    StateMemoryblock1.allocate();
    StateMemoryblock3.allocate();
}


CasinoDPTable::~CasinoDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2.absolve();
        StateMemoryblock1.absolve();
        StateMemoryblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& CasinoDPTable::getTransitionId(int id) { return id>=0 && id<_CasinotransNum ? _CasinotransitionId[id] : _Casinoempty; }
const string& CasinoDPTable::getEmissionId(int id) { return id>=0 && id<_CasinoemitNum ? _CasinoemissionId[id] : _Casinoempty; }
const string& CasinoDPTable::getStateId(int id) { return id>=0 && id<_CasinostateNum ? _CasinostateId[id] : _Casinoempty; }
const string& CasinoDPTable::getOutputId(int id) { return id>=0 && id<_CasinooutputNum ? _CasinooutputId[id] : _Casinoempty; }
int CasinoDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_CasinostateNum;i++) {
            (*pmId)[_CasinostateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_CasinoemitNum; i++) {
            (*pmId)[_CasinoemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_CasinotransNum; i++) {  
            (*pmId)[_CasinotransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_CasinooutputNum; i++) {
            (*pmId)[_CasinooutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "CasinoDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat CasinoDPTable::getProb(const string sState ,int iPos0) const
{
    return getProb(getId(sState) ,iPos0);
}


bfloat CasinoDPTable::getProb(int iState ,int iPos0) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=1)&&(iPos0+0<=iLen+0)) {
            CurStateMemoryblock2Secondary = this->StateMemoryblock2.read((iPos0-(0))-(1));
            return CurStateMemoryblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen+0)&&(iPos0+0<=iLen+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

int CasinoBaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "CasinoBaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


int CasinoBaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "CasinoBaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


void CasinoBaumWelch::resetCounts() {
    static bool bInited = false;
    if (!bInited) {
        static const int aTemp[] = {0, 1, 2, 3, 4, 5, 6};
        for (int i=0; i<7; i++) {
            transitionIdentifier0[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_CasinotransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<7; i++) {
        
        transitionBaumWelchCount0[i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {0};
        for (int i=0; i<1; i++) {
            emissionIdentifier0[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_CasinoemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<1; i++) {
        
        emissionBaumWelchCount0[i] = 0.0;
    }
    if (!bInited) {
        static const int aTemp[] = {1, 2};
        for (int i=0; i<2; i++) {
            emissionIdentifier1[i] = aTemp[i];
            aemissionIdx[aTemp[i]] = i;
            mId[_CasinoemissionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<2; i++) {
        for(int v00=0;v00<6;v00++)
        emissionBaumWelchCount1[v00][i] = 0.0;
    }
    bInited = true;
};


int CasinoBaumWelch::transitionIdentifier0[];
int CasinoBaumWelch::emissionIdentifier0[];
int CasinoBaumWelch::emissionIdentifier1[];

void CasinoBaumWelch::scaleCounts(bfloat scale) {
    for (int i=0; i<7; i++) {
        
        transitionBaumWelchCount0[i] *= scale;
    }
    for (int i=0; i<1; i++) {
        
        emissionBaumWelchCount0[i] *= scale;
    }
    for (int i=0; i<2; i++) {
        for(int v00=0;v00<6;v00++)
        emissionBaumWelchCount1[v00][i] *= scale;
    }
}


map<const string,int> CasinoBaumWelch::mId;
int CasinoBaumWelch::atransitionIdx[];
int CasinoBaumWelch::aemissionIdx[];

const extern string _NoEmissionCasinostateId[];
const extern string _NoEmissionCasinoemissionId[];
const extern string _NoEmissionCasinotransitionId[];
const extern string _NoEmissionCasinotransF[];
const extern string _NoEmissionCasinotransT[];
const extern string _NoEmissionCasinotransP[];
const extern string _NoEmissionCasinotransE[];
const extern string _NoEmissionCasinooutputId[];
const extern string _NoEmissionCasinoempty;
const extern int _NoEmissionCasinostateNum;
const extern int _NoEmissionCasinoemitNum;
const extern int _NoEmissionCasinotransNum;
const extern int _NoEmissionCasinooutputNum;

NoEmissionCasinoDPTable::NoEmissionCasinoDPTable() : isInCharge(true), stateId(_NoEmissionCasinostateId), emissionId(_NoEmissionCasinoemissionId), transitionId(_NoEmissionCasinotransitionId), transitionFrom(_NoEmissionCasinotransF), transitionTo(_NoEmissionCasinotransT), transitionProb(_NoEmissionCasinotransP), transitionEmit(_NoEmissionCasinotransE), outputId(_NoEmissionCasinooutputId) {
    // init code:
    StateMemoryNEblock1.allocate();
    StateMemoryNEblock2.allocate();
    StateMemoryNEblock3.allocate();
}


NoEmissionCasinoDPTable::~NoEmissionCasinoDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryNEblock1.absolve();
        StateMemoryNEblock2.absolve();
        StateMemoryNEblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& NoEmissionCasinoDPTable::getTransitionId(int id) { return id>=0 && id<_NoEmissionCasinotransNum ? _NoEmissionCasinotransitionId[id] : _NoEmissionCasinoempty; }
const string& NoEmissionCasinoDPTable::getEmissionId(int id) { return id>=0 && id<_NoEmissionCasinoemitNum ? _NoEmissionCasinoemissionId[id] : _NoEmissionCasinoempty; }
const string& NoEmissionCasinoDPTable::getStateId(int id) { return id>=0 && id<_NoEmissionCasinostateNum ? _NoEmissionCasinostateId[id] : _NoEmissionCasinoempty; }
const string& NoEmissionCasinoDPTable::getOutputId(int id) { return id>=0 && id<_NoEmissionCasinooutputNum ? _NoEmissionCasinooutputId[id] : _NoEmissionCasinoempty; }
int NoEmissionCasinoDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_NoEmissionCasinostateNum;i++) {
            (*pmId)[_NoEmissionCasinostateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_NoEmissionCasinoemitNum; i++) {
            (*pmId)[_NoEmissionCasinoemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_NoEmissionCasinotransNum; i++) {  
            (*pmId)[_NoEmissionCasinotransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_NoEmissionCasinooutputNum; i++) {
            (*pmId)[_NoEmissionCasinooutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "NoEmissionCasinoDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat NoEmissionCasinoDPTable::getProb(const string sState ) const
{
    return getProb(getId(sState) );
}


bfloat NoEmissionCasinoDPTable::getProb(int iState ) const
{
    const bfloat *CurStateMemoryNEblock1Secondary;
    const bfloat *CurStateMemoryNEblock2Secondary;
    const bfloat *CurStateMemoryNEblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if (1) {
            CurStateMemoryNEblock1Secondary = this->StateMemoryNEblock1.read();
            return CurStateMemoryNEblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if (1) {
            CurStateMemoryNEblock2Secondary = this->StateMemoryNEblock2.read();
            return CurStateMemoryNEblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if (1) {
            CurStateMemoryNEblock3Secondary = this->StateMemoryNEblock3.read();
            return CurStateMemoryNEblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)
/* Matrix inverse, adapted from Numerical Recipes (Press et al.) by Yun Song, 26/6/2002 */

inline void hmmocSwap( double& i, double& j ) {
    double tmp = i;
    i = j;
    j = tmp;
}

void hmmocMatrixInverse( const hmmocMatrix& iM, hmmocMatrix& iInv )
{
    int iDimen = iM.iDim;
    int id1, id2;
    int icol=0, irow=0;
    double big, fElt, pivinv;
    
    // copy contents of iM into matrix iInv
    iInv.assign( iM );
    
    vector<int> indxc(iDimen);  // piv column index
    vector<int> indxr(iDimen);  // piv row index
    vector<int> ipiv(iDimen);
    
    for (id1=0; id1 < iDimen; id1++) 
    ipiv[id1]=0;  
    for (int i=0; i < iDimen; i++) {     //reduce over columns
        big = 0.0;
        for (int j=0; j < iDimen; j++) {   //search for pivots
            if(ipiv[j] != 1) {
                for(int k=0; k < iDimen; k++) {
                    if(ipiv[k] == 0) {
                        if(fabs(iInv(j,k)) >= big) {
                            big=fabs(iInv(j,k));
                            irow=j;
                            icol=k;
                        }
                    } 
                    else if (ipiv[k] > 1) {
                        cerr<< "Singular Matrix-1" <<endl;
                        exit(1);
                    }
                }
            }
        }
        ++(ipiv[icol]);
        if (irow != icol) {
            for (int l=0;l<iDimen;l++) {   //exchange rows
                hmmocSwap( iInv(irow,l), iInv(icol,l) );
            }
        }
        indxr[i]=irow;
        indxc[i]=icol;
        // divide pivot row by pivot elt
        if (iInv(icol,icol) == 0.0) {
            cerr<< "Singular Matrix-2" << endl;
            exit(1);
        }
        pivinv=1.0/iInv(icol,icol);
        iInv(icol,icol)=1.0;
        for (id1=0;id1<iDimen;id1++) 
        iInv(icol,id1) *= pivinv;
        for (id1=0;id1<iDimen;id1++) {  // reduce non-pivot rows
            if (id1 != icol) {
                fElt=iInv(id1,icol);
                iInv(id1,icol)=0.0;
                for (id2=0;id2<iDimen;id2++) {
                    iInv(id1,id2) -= iInv(icol,id2)*fElt;
                }
            }
        }
    }
    for (int l=iDimen-1;l>=0;l--) {
        if (indxr[l] != indxc[l]) {
            for (int k=0;k<iDimen;k++) { //exchange columns in backward order
                hmmocSwap( iInv(k,indxr[l] ), iInv(k,indxc[l]) );
            }
        }
    }
}

bfloat hmmocMax(bfloat i, bfloat j) { return i>j ? i : j; }
void hmmocMaxInPlace(bfloat& i, bfloat j) { if (i<j) i=j; }
ostream& operator<<(ostream& os, const Path& p)
{
    for (unsigned int i=0; i<p.size(); i++) {
        os << p.fromState(i) << "--{";
            for (unsigned int j=0; j<p.emission(i).size(); j++) {
                if (j) os<<",";
                os<<p.emission(i)[j];
            }
        os<<"};"<<p.prob(i)<<"-->"<<p.toState(i)<<endl;
    }
    return os;
}

void SimplePath::addEdge(int tr, double p, vector<int>& e, int f, int t) {
    transitions.push_back(tr);
    probs.push_back(p);
    emissions.push_back(e);
    froms.push_back(f);
    tos.push_back(t);
}

void SimplePath::reverse() 
{
    std::reverse(transitions.begin(),transitions.end());
    std::reverse(probs.begin(),probs.end());
    std::reverse(emissions.begin(),emissions.end());
    std::reverse(froms.begin(),froms.end());
    std::reverse(tos.begin(),tos.end());
}

double SimplePath::prob(int i) const {
    return probs[i];
}

int SimplePath::nextFrom(int i) const {
    if (i+1 < (int)transitions.size())
    return i+1;
    else
    return -1;
}

int SimplePath::nextTo(int i) const {
    return -1;
}

const vector<int>& SimplePath::emission(int i) const {
    return emissions[i];
}

int SimplePath::fromState(int i) const {
    return froms[i];
}

int SimplePath::toState(int i) const {
    return tos[i];
}

const string _CasinostateId[] = {"start","honest","dishonest","end"};
const string _CasinoemissionId[] = {"empty","emitDishonest","emitHonest"};
const string _CasinotransitionId[] = {"id$13","id$14","id$15","id$16","id$17","id$18","id$19"};
const string _CasinotransF[] = {"start","honest","honest","dishonest","dishonest","honest","dishonest"};
const string _CasinotransT[] = {"honest","honest","dishonest","dishonest","honest","end","end"};
const string _CasinotransP[] = {"one","stayHonest","goDishonest","stayDishonest","goHonest","goStop","goStop"};
const string _CasinotransE[] = {"emitHonest","emitHonest","emitDishonest","emitDishonest","emitHonest","empty","empty"};
const string _CasinooutputId[] = {"sequence"};
const string _Casinoempty = "";
const int _CasinostateNum = 4;
const int _CasinoemitNum = 3;
const int _CasinotransNum = 7;
const int _CasinooutputNum = 1;




bfloat Forward(CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen) {
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock1From;
    const bfloat *CurStateMemoryblock2From;
    bfloat *CurStateMemoryblock3To;
    const bfloat *CurStateMemoryblock3From;
    int iPrevSlowCoord;
    int iSymbol[1];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    CasinoDPTable dp(iLen);
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    dp.StateMemoryblock1.write()[0] = 1.0;
    dp.StateMemoryblock1.written();
    iPrevSlowCoord = -1;
    for (int iPos0=0; iPos0<iLen+1; ++iPos0) {
        if ((iPos0+0<=0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+-1>=0)) {
                iSymbol[0] = aSeq[iPos0+-1];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            iTempResult[0] = 1/6.0;
            /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
            somewhere in the code -- its appearance in this comment stops it from warning */
            iEmission[0] = iTempResult[0];
            iTempResult[0] = iPar.aEmitDishonest[ iSymbol[0] - '1' ];
            iEmission[1] = iTempResult[0];
            if ((iPos0+-1<=0)) {
                CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock1From[0];
            }
            if ((iPos0+-1>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(1))-(1));
                CurStateMemoryblock2To[0] += ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[0] += ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                CurStateMemoryblock2To[1] = ((iTransition[2])*(iEmission[1]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock2To[1] += ((iTransition[3])*(iEmission[1]))*CurStateMemoryblock2From[1];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0>=iLen+0)) {
            CurStateMemoryblock3To = dp.StateMemoryblock3.write();
            iEmission[0] = 1.0;
            if ((iPos0+0>=1)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(1));
                CurStateMemoryblock3To[0] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0];
                CurStateMemoryblock3To[0] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[1];
            }
            dp.StateMemoryblock3.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
        iTempProb[0] = CurStateMemoryblock3From[0];
    }
    *ppOutTable = new CasinoDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat Backward(CasinoBaumWelch& bw,CasinoDPTable* pInTable,CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen) {
    const bfloat *CurStateMemoryblock3Secondary;
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock2From;
    unsigned char alphaSymboldice[6] = {'1', '2', '3', '4', '5', '6'};
    unsigned char alphaIndexdice[256];
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[1];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[3];
    CasinoDPTable dp(iLen);
    CasinoDPTable dp2(*pInTable);
    // make sure tables don't get deleted
    dp2.isInCharge = false;
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    for (int i=0; i<256; i++) {
        alphaIndexdice[i]=0;
    }
    for (int i=0; i<6; i++) {
        alphaIndexdice[alphaSymboldice[i]]=i;
    }
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos0=iLen+0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock3Secondary = dp2.StateMemoryblock3.read();
        iTempProb[2] = CurStateMemoryblock3Secondary[0];
        bw.scaleCounts(iTempProb[2]);
    }
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen+-1)) {
                iSymbol[0] = aSeq[iPos0+0];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            CurStateMemoryblock2Secondary = dp2.StateMemoryblock2.read((iPos0-(0))-(1));
            iTempResult[0] = 1/6.0;
            /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
            somewhere in the code -- its appearance in this comment stops it from warning */
            iEmission[0] = iTempResult[0];
            iTempResult[0] = iPar.aEmitDishonest[ iSymbol[0] - '1' ];
            iEmission[1] = iTempResult[0];
            if ((iPos0+1<=iLen+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[1] = iTempProb[1] = ((iTransition[3])*(iEmission[1]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount0[3] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexdice[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount0[4] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexdice[iSymbol[0]]][1] += iTempProb[1];
                CurStateMemoryblock2To[0] = iTempProb[1] = ((iTransition[2])*(iEmission[1]))*CurStateMemoryblock2From[1];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount0[2] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexdice[iSymbol[0]]][0] += iTempProb[1];
                CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount0[1] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexdice[iSymbol[0]]][1] += iTempProb[1];
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock3From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[1];
                bw.transitionBaumWelchCount0[6] += iTempProb[1];
                bw.emissionBaumWelchCount0[0] += iTempProb[1];
                CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock3From[0];
                iTempProb[1] *= CurStateMemoryblock2Secondary[0];
                bw.transitionBaumWelchCount0[5] += iTempProb[1];
                bw.emissionBaumWelchCount0[0] += iTempProb[1];
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen+-1)) {
                iSymbol[0] = aSeq[iPos0+0];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            CurStateMemoryblock1Secondary = dp2.StateMemoryblock1.read();
            iTempResult[0] = 1/6.0;
            /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
            somewhere in the code -- its appearance in this comment stops it from warning */
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = iTempProb[1] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[0];
                iTempProb[1] *= CurStateMemoryblock1Secondary[0];
                bw.transitionBaumWelchCount0[0] += iTempProb[1];
                bw.emissionBaumWelchCount1[alphaIndexdice[iSymbol[0]]][1] += iTempProb[1];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    bw.scaleCounts(1.0 / iTempProb[2]);
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new CasinoDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat Viterbi_recurse(CasinoDPTable** ppOutTable,Params iPar,char *aSeq,int iLen) {
    bfloat iTransition[7];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iSymbol[1];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    CasinoDPTable dp(iLen);
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    for (int iPos0=(iLen+1)-1; iPos0>=0; --iPos0) {
        if ((iPos0+0>=iLen+0)) {
        }
        if ((iPos0+0>=1)) {
            if ((iPos0+0<=iLen+-1)) {
                iSymbol[0] = aSeq[iPos0+0];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(1));
            iTempResult[0] = iPar.aEmitDishonest[ iSymbol[0] - '1' ];
            iEmission[0] = iTempResult[0];
            iTempResult[0] = 1/6.0;
            /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
            somewhere in the code -- its appearance in this comment stops it from warning */
            iEmission[1] = iTempResult[0];
            if ((iPos0+1<=iLen+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock2To[1] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[1];
                hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[4])*(iEmission[1]))*CurStateMemoryblock2From[0] );
                CurStateMemoryblock2To[0] = ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2From[1];
                hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[1])*(iEmission[1]))*CurStateMemoryblock2From[0] );
            }
            iEmission[0] = 1.0;
            if ((iPos0+0>=iLen+0)) {
                CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock3From[0] );
            }
            dp.StateMemoryblock2.written();
        }
        if ((iPos0+0<=0)) {
            if ((iPos0+0<=iLen+-1)) {
                iSymbol[0] = aSeq[iPos0+0];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.write();
            iTempResult[0] = 1/6.0;
            /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
            somewhere in the code -- its appearance in this comment stops it from warning */
            iEmission[0] = iTempResult[0];
            if ((iPos0+1<=iLen+0)) {
                CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                CurStateMemoryblock1To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock2From[0];
            }
            dp.StateMemoryblock1.written();
        }
        iPrevSlowCoord = iPos0;
    }
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
        iTempProb[0] = CurStateMemoryblock1From[0];
    }
    *ppOutTable = new CasinoDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& Viterbi_trace(CasinoDPTable* pInTable,Params iPar,char *aSeq,int iLen) {
    bfloat iTransition[7];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[1];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[2];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    static const int stateTable[] = {1, 1, 2, 2, 1, 3, 3};
    static const int stateFromTable[] = {0, 1, 1, 2, 2, 1, 2};
    static const int iPos0Table[] = {1, 1, 1, 1, 1, 0, 0};
    CasinoDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos0=0;
        if (iPos0==iPos0) {} // avoid 'unused variable' warnings
        iTempIntVec[0] = 0;
        while (iTempIntVec[0] != 3) {
            iTempIntVec[1] = 2;
            if ((iPos0+0<=iLen+-1)) {
                iSymbol[0] = aSeq[iPos0+0];
            } 
            else { 
                iSymbol[0] = '1' /* dummy value */;
                
            }
            CurStateMemoryblock1To = dp.StateMemoryblock1.read();
            CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(1));
            if ((iPos0+1<=iLen+0)) {
                iTempResult[0] = iPar.aEmitDishonest[ iSymbol[0] - '1' ];
                iEmission[0] = iTempResult[0];
                iTempResult[0] = 1/6.0;
                /* This probability does not depend on the symbol.  HMMoC warns if it does not see the label 'iSymbol[0]'
                somewhere in the code -- its appearance in this comment stops it from warning */
                iEmission[1] = iTempResult[0];
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(1));
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 0:
                    iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 0;
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 3;
                    iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 4;
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[1]*CurStateMemoryblock2To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[1];
                    iTempIntVec[iTempIntVec[1]++] = 1;
                    iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[1];
                    iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 2;
                    break;
                }
            }
            CurStateMemoryblock3To = dp.StateMemoryblock3.read();
            if ((iPos0+0>=iLen+0)) {
                iEmission[0] = 1.0;
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                switch (iTempIntVec[0]) {
                    default:
                    break;
                    case 1:
                    iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 5;
                    break;
                    case 2:
                    iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock3To[0];
                    iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[0];
                    iTempIntVec[iTempIntVec[1]++] = 6;
                    break;
                }
            }
            iTempVector[0] = 0.0;
            for (int i=2; i<iTempIntVec[1]; i++) {
                if (iTempVector[i]>iTempVector[0]) {
                    iTempVector[0]=iTempVector[i];
                    iTempIntVec[0] = i;
                }
            }
            emit.resize(1);
            emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
            pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
            iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
            iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
        }
    }
    return *pPath;
};





Path& NESample(NoEmissionCasinoDPTable* pInTable,Params iPar) {
    bfloat iTransition[7];
    const bfloat *CurStateMemoryNEblock1To;
    const bfloat *CurStateMemoryNEblock2To;
    const bfloat *CurStateMemoryNEblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iSymbol[0];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[9];
    /* temporary int vector storage */
    int iTempIntVec[6];
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    static const int stateTable[] = {2, 2, 1, 1, 2, 3, 3};
    static const int stateFromTable[] = {0, 2, 2, 1, 1, 2, 1};
    NoEmissionCasinoDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    iTempIntVec[0] = 0;
    while (iTempIntVec[0] != 3) {
        iTempIntVec[1] = 2;
        CurStateMemoryNEblock1To = dp.StateMemoryNEblock1.read();
        CurStateMemoryNEblock2To = dp.StateMemoryNEblock2.read();
        if (1) {
            iEmission[0] = 1.0;
            switch (iTempIntVec[0]) {
                default:
                break;
                case 2:
                iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[1]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 1;
                iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[2]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 2;
                break;
                case 1:
                iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[4]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 4;
                iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[3]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 3;
                break;
                case 0:
                iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[0]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 0;
                break;
            }
        }
        CurStateMemoryNEblock3To = dp.StateMemoryNEblock3.read();
        if (1) {
            iEmission[0] = 1.0;
            switch (iTempIntVec[0]) {
                default:
                break;
                case 2:
                iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[5]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 5;
                break;
                case 1:
                iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*1.0;
                iTempVector[iTempIntVec[1]+3] = iTransition[6]*iEmission[0];
                iTempIntVec[iTempIntVec[1]++] = 6;
                break;
            }
        }
        iTempVector[0] = iTempVector[1] = 0.0;
        for (int i=2; i<iTempIntVec[1]; i++) {
            iTempVector[0] += iTempVector[i];
        }
        iTempVector[0] *= (random() / (double)RAND_MAX);
        iTempIntVec[0] = 1;
        while (iTempVector[0]>=iTempVector[1] && ++iTempIntVec[0]<iTempIntVec[1]) {
            iTempVector[1] += iTempVector[iTempIntVec[0]];
        }
        if (iTempIntVec[0]==iTempIntVec[1]) {
            cerr << "Error in sampler -- zero probabilities?" << endl;
            exit(1);
        }
        emit.resize(0);
        pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+3],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
        iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
    }
    return *pPath;
};



const string _NoEmissionCasinostateId[] = {"NEstart","NEdishonest","NEhonest","NEend"};
const string _NoEmissionCasinoemissionId[] = {"NEempty"};
const string _NoEmissionCasinotransitionId[] = {"id$45","id$46","id$47","id$48","id$49","id$50","id$51"};
const string _NoEmissionCasinotransF[] = {"NEstart","NEhonest","NEhonest","NEdishonest","NEdishonest","NEhonest","NEdishonest"};
const string _NoEmissionCasinotransT[] = {"NEhonest","NEhonest","NEdishonest","NEdishonest","NEhonest","NEend","NEend"};
const string _NoEmissionCasinotransP[] = {"one","stayHonest","goDishonest","stayDishonest","goHonest","goStop","goStop"};
const string _NoEmissionCasinotransE[] = {"NEempty","NEempty","NEempty","NEempty","NEempty","NEempty","NEempty"};
const string _NoEmissionCasinooutputId[] = {};
const string _NoEmissionCasinoempty = "";
const int _NoEmissionCasinostateNum = 4;
const int _NoEmissionCasinoemitNum = 1;
const int _NoEmissionCasinotransNum = 7;
const int _NoEmissionCasinooutputNum = 0;




bfloat NEBackward(NoEmissionCasinoDPTable** ppOutTable,Params iPar) {
    bfloat iTransition[7];
    bfloat *CurStateMemoryNEblock2To;
    const bfloat *CurStateMemoryNEblock3From;
    hmmocMatrix matrix0(2);
    hmmocMatrix matrix0inv;
    bfloat *CurStateMemoryNEblock1To;
    const bfloat *CurStateMemoryNEblock2From;
    const bfloat *CurStateMemoryNEblock1From;
    int iPrevSlowCoord;
    int iSymbol[0];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[2];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    NoEmissionCasinoDPTable dp;
    iTransition[0] = 1.0;
    
    iTransition[1] = 1.0 - iPar.iGoDishonest - iPar.iGoStop;
    
    iTransition[2] = iPar.iGoDishonest;
    
    iTransition[3] = 1.0 - iPar.iGoHonest - iPar.iGoStop;
    
    iTransition[4] = iPar.iGoHonest;
    
    iTransition[5] = iPar.iGoStop;
    
    iTransition[6] = iPar.iGoStop;
    dp.StateMemoryNEblock3.write()[0] = 1.0;
    dp.StateMemoryNEblock3.written();
    matrix0.unitMatrix();
    matrix0(0,0) += -iTransition[3];
    matrix0(1,0) += -iTransition[4];
    matrix0(1,1) += -iTransition[1];
    matrix0(0,1) += -iTransition[2];
    hmmocMatrixInverse( matrix0, matrix0inv );
    iPrevSlowCoord = -1;
    if (1) {
    }
    if (1) {
        CurStateMemoryNEblock2To = dp.StateMemoryNEblock2.write();
        iEmission[0] = 1.0;
        if (1) {
            CurStateMemoryNEblock3From = dp.StateMemoryNEblock3.read();
            CurStateMemoryNEblock2To[1] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryNEblock3From[0];
            CurStateMemoryNEblock2To[0] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryNEblock3From[0];
        }
        if (1) {
            iTempVector[0] = CurStateMemoryNEblock2To[0];
            iTempVector[1] = CurStateMemoryNEblock2To[1];
            CurStateMemoryNEblock2To[0] = matrix0inv(0,0)*iTempVector[0] + matrix0inv(1,0)*iTempVector[1];
            CurStateMemoryNEblock2To[1] = matrix0inv(0,1)*iTempVector[0] + matrix0inv(1,1)*iTempVector[1];
        }
        dp.StateMemoryNEblock2.written();
    }
    if (1) {
        CurStateMemoryNEblock1To = dp.StateMemoryNEblock1.write();
        iEmission[0] = 1.0;
        if (1) {
            CurStateMemoryNEblock2From = dp.StateMemoryNEblock2.read();
            CurStateMemoryNEblock1To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryNEblock2From[1];
        }
        dp.StateMemoryNEblock1.written();
    }
    /* end of useful scope of matrix matrix0inv */
    iPrevSlowCoord = -1;
    CurStateMemoryNEblock1From = dp.StateMemoryNEblock1.read();
    iTempProb[0] = CurStateMemoryNEblock1From[0];
    *ppOutTable = new NoEmissionCasinoDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};



/* --- end of HMMoC-generated file --- */
