<?xml version="1.0"?>
<!--
      This file is part of HMMoC 1.3, a hidden Markov model compiler.
      Copyright (C) 2006 by Gerton Lunter, Oxford University.
  
      HMMoC is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of the License, or
      (at your option) any later version.
  
      HMMOC is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with HMMoC; if not, write to the Free Software
      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->

<snippets>

<author name="Gerton Lunter"/>

 <!-- Contains pieces of code that are used internally -->
 <!-- where=includes, classdefinitions, subroutines, declarations -->
 
 <code id="hmlScopeOpen" type="statement"><identifier value="__"/>  <!-- /* Opened scope __ */   --> </code>

 <code id="hmlScopeCode" type="statement"><identifier value="__"/>  <!-- /* Code for scope __ */ --> </code>

 <code id="hmlScopeClose" type="statement"><identifier value="__"/> <!-- /* Closed scope __ */   --> </code>

 <code id="hmlBookAlpha" type="statement"> 
/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated _description_ */

/*
    This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
    Copyright (C) 2006 by Gerton Lunter, Oxford University.

    HMMoC and works based on it are free software; you can redistribute 
    it and/or modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    HMMOC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with HMMoC; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 </code>


 <code id="hmlBookOmega" type="statement"> 
  /* --- end of HMMoC-generated file --- */ 
 </code>

<code id="hmlNamespace">
namespace hmmoc {
/* line */
</code>

<code id="hmlNamespaceEnd">
} // namespace hmmoc
/* line */
</code>

 <code id="hmlHeaderStart" type="statement"><identifier value="_file_"/>
 #IFNDEF __file__
 #DEFINE __file__
   /* line */
 </code>

 <code id="hmlHeaderEnd" type="statement"><identifier value="_file_"/>
   /* line */
 #ENDIF // __file__
 </code>

 <code id="hmlForLoop" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
   <![CDATA[
     for (int _a_=_b_; _a_<_c_; ++_a_) { 
   ]]></code>

 <code id="hmlInnerLoopStart" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_d_"/><identifier value="_bandinginstance_"/>
  <![CDATA[
     for (int _a_=_b_; iPrevSlowCoord != _b_ && _a_==_b_ && _c_<=_a_ && _a_<_d_; ++_a_) {
  ]]>
</code>

 <code id="hmlInnerLoopStartPastBandedClique" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_d_"/><identifier value="_bandinginstance_"/>
  <![CDATA[
     for (int _a_=_b_; _bandinginstance_.lastColumnEntry() && _a_==_b_ && _c_<=_a_ && _a_<_d_; ++_a_) {
  ]]>
</code>


 <code id="hmlInnerLoopEnd" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_d_"/><identifier value="_e_"/>
  <![CDATA[
  }
  ]]>
</code>

 <code id="hmlLoopStart1" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   <![CDATA[
     for (int _a_=_b_; _a_<_c_; ++_a_) { 
   ]]></code>

 <code id="hmlLoopEnd1" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   }
 </code>

 <code id="hmlLoopStart1Backward" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   <![CDATA[
     for (int _a_=(_c_)-1; _a_>=_b_; --_a_) { 
   ]]></code>

 <code id="hmlLoopEnd1Backward" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   }
 </code>

 <code id="hmlSingleStart1" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   <![CDATA[
     {
       int _a_=_b_;
       if (_a_==_a_) {} // avoid 'unused variable' warnings
   ]]></code>

 <code id="hmlSingleEnd1" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   }
 </code>

 <code id="hmlSingleStart1Backward" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   <![CDATA[
     {
       int _a_=_b_;
       if (_a_==_a_) {} // avoid 'unused variable' warnings
   ]]></code>

 <code id="hmlSingleEnd1Backward" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   }
 </code>

 <code id="hmlStateVectorDefine" type="statement" init="extendedreal"><identifier value="_a_"/><identifier value="_b_"/> 
 <![CDATA[
   typedef States<_extreal_,_b_> States_a_;
 ]]>
 </code>

 <code id="hmlStateMemoryDeclare1" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_dptable_"/>
 <![CDATA[
   _dptable_<States_a_,_c_> StateMemory_a_;
 ]]>
 </code>

 <code id="hmlStateMemoryDeclareFolded" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_dptable_"/>
 <![CDATA[
   FoldedTable<_dptable_,States_a_,_c_> StateMemory_a_;
 ]]>
 </code>

 <code id="hmlCurStateMemoryDeclare" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/> 
   _extreal_ *CurStateMemory_a__b_;
 </code>

 <code id="hmlConstCurStateMemoryDeclare" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_const_"/> 
  <![CDATA[
  _const_ _extreal_ *CurStateMemory_a__b_;
  ]]>
 </code>

 <code id="hmlStateMemoryAlloc" type="statement"><identifier value="_a_"/><identifier value="_b_"/> <!-- <identifier value="_c_"/><identifier value="_d_"/>  -->
   <![CDATA[
    StateMemory_a_.allocate(_b_);
  ]]>
 </code>

 <code id="hmlStateMemoryAbsolve" type="statement"><identifier value="_a_"/>
    StateMemory_a_.absolve();
 </code>

 <code id="hmlStateMemoryInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
 </code>

 <code id="hmlStateMemoryStartInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    dp.StateMemory_a_.write(_b_)[_c_] = 1.0;
    dp.StateMemory_a_.written();
 </code>

 <code id="hmlStateMemoryAccess" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    CurStateMemory_a__b_ = dp.StateMemory_a_.read(_c_);
 </code>

 <code id="hmlStateMemoryAccessWrite" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    CurStateMemory_a__b_ = dp.StateMemory_a_.write(_c_);
 </code>

 <code id="hmlSecondaryStateMemoryAccess" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    CurStateMemory_a__b_ = dp2.StateMemory_a_.read(_c_);
 </code>

 <code id="hmlThisStateMemoryAccess" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    CurStateMemory_a__b_ = this->StateMemory_a_.read(_c_);
 </code>

 <code id="hmlStateMemoryAccessEnd" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
 </code>

 <code id="hmlStateMemoryAccessWriteEnd" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    dp.StateMemory_a_.written();
 </code>

 <code id="hmlSecondaryStateMemoryAccessEnd" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
 </code>

 <code id="hmlThisStateMemoryAccessEnd" type="statement"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
 </code>

 <code id="hmlStateAccess"><identifier value="_a_"/><identifier value="_b_"/>
    CurStateMemory_a_[_b_]
 </code>

 <code id="hmlStateInit"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
    CurStateMemory_a__b_[_c_] = 0.0;
    /* line */
 </code>

 <code id="hmlStateAccessInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
    _a_=_b_;
 </code>

 <code id="hmlStateAccessExit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
    _b_=_a_;
 </code>

 <code id="hmlRealIntermediateDeclare" type="statement"><identifier value="_a_"/> <identifier value="_b_"/> 
    /* temporary storage for ordinary reals */
    register _shortreal_ _a_[_b_];
 </code>

 <code id="hmlProbIntermediateDeclare" type="statement"><identifier value="_a_"/> <identifier value="_b_"/> 
    /* temporary storage for extended-exponent reals */
    register _extreal_ _a_[_b_];
 </code>

 <code id="hmlVectorIntermediateDeclare" type="statement"><identifier value="_a_"/> <identifier value="_b_"/> 
    /* temporary vector storage */
    _extreal_ _a_[_b_];
 </code>

 <code id="hmlIntVecIntermediateDeclare" type="statement"><identifier value="_a_"/> <identifier value="_b_"/> 
    /* temporary int vector storage */
    int _a_[_b_];
 </code>

 <code id="hmlTransitionDeclare" type="statement"><identifier value="_a_"/>
    _extreal_ iTransition[_a_];
 </code>

 <code id="hmlTransitionInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
    iTransition[_a_] = _b_;
 </code>

 <code id="hmlTransition"><identifier value="_a_"/>
    iTransition[_a_]
 </code>

 <code id="hmlEmissionDeclare" type="statement"><identifier value="_a_"/>
    _extreal_ iEmission[_a_];
 </code>

 <code id="hmlEmissionInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
    iEmission[_a_] = _b_;
 </code>

 <code id="hmlEmission"><identifier value="_a_"/>
    iEmission[_a_]
 </code>

 <code id="hmlSymbolDeclare" type="statement"><identifier value="_a_"/>
 <![CDATA[
    int iSymbol[_a_];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
 ]]>
 </code>

 <code id="hmlSymbolDummyValue"><identifier value="_a_"/>
    _a_ /* dummy value */
 </code>

 <code id="hmlSymbolInit" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
    iSymbol[_a_] = _b_;
 </code>

 <code id="hmlSymbol"><identifier value="_a_"/>
    iSymbol[_a_]
 </code>

 <code id="hmlConditional" type="statement"><identifier value="_a_"/>
    if (_a_) {
 </code>

 <code id="hmlConditionalElse" type="statement"><identifier value="_a_"/>
    } 
    else { 
      _a_
    }
 </code>

 <code id="hmlConditionalEnd" type="statement">
    }
 </code>
 
 <code id="hmlTrue" type="expression"> 
    1 
 </code>    

 <code id="hmlAlphabetDeclare" type="statement"><identifier value="_id_"/><identifier value="_size_"/><identifier value="_alphabet_"/><identifier value="_type_"/><identifier value="_maxchar_"/>
   _type_ alphaSymbol_id_[_size_] = {_alphabet_};
   _type_ alphaIndex_id_[_maxchar_];
 </code>

 <code id="hmlAlphabetInit" type="statement"><identifier value="_id_"/><identifier value="_size_"/><identifier value="_type_"/><identifier value="_maxchar_"/>
   <![CDATA[
   for (int i=0; i<_maxchar_; i++) {
     alphaIndex_id_[i]=0;
   }
   for (int i=0; i<_size_; i++) {
     alphaIndex_id_[alphaSymbol_id_[i]]=i;
   }
   ]]>
 </code>

 <code id="hmlAlphabetGetIndex" type="expression"><identifier value="_id_"/><identifier value="_sym_"/>
   alphaIndex_id_[_sym_]
 </code>

 <code id="hmlAlphabetGetSymbol" type="expression"><identifier value="_id_"/><identifier value="_idx_"/>
   alphaSymbol_id_[_idx_]
 </code>



<!--  ******* Baum-Welch code follows ******  -->



 <code id="hmlCountClassA" type="statement"><identifier value="_hmmid_"/>
   <![CDATA[

#ifndef __hmmid__baumwelch_table_defined_
#define __hmmid__baumwelch_table_defined_

   class _hmmid_BaumWelch {
  public:
   // Default copy constructor is used.
   // Void constructor:
   _hmmid_BaumWelch() { resetCounts(); }
   // Not calling resetCounts() across calls allows to aggregate results over multiple datasets
   void resetCounts();
   void scaleCounts(_extreal_ scale);
   // Translate an identifier (string or integer) to the index into their corresponding Baum-Welch counter array (below)
   // Which array is used for any particular emission/transition depends on its order signature - see documentation for details
   int transitionIndex(int intId) const { return atransitionIdx[intId]; }
   int transitionIndex(string strId) const;
   int emissionIndex(int intId) const { return aemissionIdx[intId]; }
   int emissionIndex(string strId) const;
   // Now follow, in triplets (one for each order signature):
   //  Transition or emission counters;
   //  Array of identifiers; and
   //  Dimension of array (number of counters).
 ]]></code>

 <code id="hmlCountClassBA" type="statement">
    <identifier value="_hmmid_"/>
    <![CDATA[
  #ifndef __hmmid__baumwelch_table_func_defined_
  #define __hmmid__baumwelch_table_func_defined_

  int _hmmid_BaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
      cout << "_hmmid_BaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
      return -1;
    }
    return iter->second;
  }
  /* line */
  int _hmmid_BaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
      cout << "_hmmid_BaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
      return -1;
    }
    return iter->second;
  }
  /* line */
  void _hmmid_BaumWelch::resetCounts() {
       static bool bInited = false;
    ]]>
 </code>

 <!-- Note:
      _type_ = trans or emit
      _sig_ = signature ("0000" eg.)
      _dim_ = # of transitions/emissions with this signature
      _symloopcode_ = for(int k=0;k<10;k++) etc.
      _symbols_ = [i][j][k][l] or similar 
      _ids_ = ids of transitions/emissions of this signature -->
 <code id="hmlCountClassB" type="statement"><identifier value="_type_"/>
                                            <identifier value="_sig_"/>
                                            <identifier value="_dim_"/>
                                            <identifier value="_symloopcode_"/>
                                            <identifier value="_symbols_"/>
                                            <identifier value="_ids_"/>
                                            <identifier value="_hmmid_"/>
   <![CDATA[

     if (!bInited) {
       static const int aTemp[] = {_ids_};
       for (int i=0; i<_dim_; i++) {
         _type_Identifier_sig_[i] = aTemp[i];
         a_type_Idx[aTemp[i]] = i;
         mId[__hmmid__type_Id[aTemp[i]]] = i;
       }
     }
     for (int i=0; i<_dim_; i++) {
       _symloopcode_
       _type_BaumWelchCount_sig__symbols_[i] = 0.0;
     }

 ]]></code>
 <code id="hmlCountClassBZ" type="statement">
 <identifier value="_hmmid_"/>
  <![CDATA[
     bInited = true;
    };
    /* line */
  ]]>
 </code>

  <code id="hmlCountClassCA" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[
  /* line */
  #ifndef __hmmid__baumwelch_table_scalecounts_defined_
  #define __hmmid__baumwelch_table_scalecounts_defined_
  void _hmmid_BaumWelch::scaleCounts(_extreal_ scale) {
  ]]>
  </code>

  <code id="hmlCountClassCB" type="statement">
                                            <identifier value="_type_"/>
                                            <identifier value="_sig_"/>
                                            <identifier value="_dim_"/>
                                            <identifier value="_symloopcode_"/>
                                            <identifier value="_symbols_"/>
                                            <identifier value="_ids_"/>
                                            <identifier value="_hmmid_"/>
  <![CDATA[
    for (int i=0; i<_dim_; i++) {
      _symloopcode_
      _type_BaumWelchCount_sig__symbols_[i] *= scale;
    }
  ]]>
  </code>

  <code id="hmlCountClassCC" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[
  }
  /* line */
  map<const string,int> _hmmid_BaumWelch::mId;
  int _hmmid_BaumWelch::atransitionIdx[];
  int _hmmid_BaumWelch::aemissionIdx[];
  #endif // __hmmid__baumwelch_table_scalecounts_defined_
  ]]>
  </code>

 <code id="hmlCountClassC" type="statement"><identifier value="_type_"/>
                                             <identifier value="_sig_"/>
                                             <identifier value="_dim_"/>
                                             <identifier value="_symbols_"/>
   <![CDATA[
   _extreal_ _type_BaumWelchCount_sig__symbols_[_dim_];
   static int _type_Identifier_sig_[_dim_];   
   static const int _type_Dimension_sig_ = _dim_;
 ]]></code>


 <code id="hmlCountClassD" type="statement" init="includemap"><identifier value="_hmmid_"/>
                                                              <identifier value="_tdim_"/>
                                                              <identifier value="_edim_"/>
  <![CDATA[

   private:
   static int atransitionIdx[_tdim_];
   static int aemissionIdx[_edim_];
   static map<const string,int> mId;
};

#endif  //  __hmmid__baumwelch_table_defined_

 ]]></code>

 <code id="hmlCountClassE" type="statement"><identifier value="_type_"/>
                                             <identifier value="_sig_"/>
                                             <identifier value="_dim_"/>
                                             <identifier value="_hmmid_"/>
   <![CDATA[
   int _hmmid_BaumWelch::_type_Identifier_sig_[];   
 ]]></code>

<!--  aed 6/7/7: this additional definition is unnecessary inside the cc file and causes link errors on some systems -->
<!--   const int _hmmid_BaumWelch::_type_Dimension_sig_; // = _dim_; -->


 <code id="hmlCountClassEZ" type="statement"><identifier value="_hmmid_"/>
 <![CDATA[
  #endif // __hmmid__baumwelch_table_func_defined_
 ]]>
 </code>



 <code id="hmlInitCount" type="statement"><identifier value="_hmmid_"/>
   <!-- Used to be: _hmmid_BaumWelch bw;  -->
 </code>

 <code id="hmlScaleCount" type="statement"><identifier value="_hmmid_"/><identifier value="_scale_"/>
   bw.scaleCounts(_scale_);
 </code>

 <code id="hmlRefCount" type="expression"><identifier value="_type_"/><identifier value="_sig_"/> <identifier value="_symbols_"/><identifier value="_idx_"/>
   bw._type_BaumWelchCount_sig__symbols_[_idx_]
 </code>

 <code id="hmlCountReturn" type="statement"><identifier value="_hmmid_"/>
   <!-- Used to be: *ppBW = new _hmmid_BaumWelch(bw); -->
 </code>

 <code id="hmlCountParameter" type="expression"><identifier value="_hmmid_"/>
   <![CDATA[
   _hmmid_BaumWelch& bw
   ]]>
 </code>



 <!-- ******* End of Baum-Welch code ****** --> 



 <code id="hmlForwardDeclaration" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
   /* line */
   _extreal_ _a_(_b_);
 </code>

 <code id="hmlForwardStart" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
   /* line */
   /* line */
   _extreal_ _a_(_b_) {
 </code>

 <code id="hmlForwardEnd" type="statement">
   };
   /* line */
 </code>

 <code id="hmlSampleFuncDeclaration" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
  <![CDATA[
   /* line */
   Path& _a_(_b_);
  ]]>
 </code>

 <code id="hmlSampleFuncStart" type="statement"><identifier value="_a_"/><identifier value="_b_"/>
  <![CDATA[
   /* line */
   /* line */
   Path& _a_(_b_) {
  ]]>
 </code>

 <code id="hmlSampleFuncEnd" type="statement">
   };
   /* line */
 </code>

 <code id="hmlMatrixDeclare" type="statement" init="hmlMatrixDef"><identifier value="_a_"/><identifier value="_b_"/>
   hmmocMatrix _a_(_b_);
 </code>

 <code id="hmlMatrixInvDeclare" type="statement" init="hmlMatrixDef"><identifier value="_a_"/>
   hmmocMatrix _a_;
 </code>

 <code id="hmlMatrixInit" type="statement" init="hmlMatrixDef"><identifier value="_a_"/>
   _a_.unitMatrix();
 </code>

 <code id="hmlComputeInverseMatrix" type="statement" init="hmlMatrixInverse"><identifier value="_a_"/><identifier value="_b_"/>
  hmmocMatrixInverse( _b_, _a_ );
 </code>

 <code id="hmlRemoveInverseMatrix" type="statement"><identifier value="_a_"/>
  /* end of useful scope of matrix _a_ */
 </code>

 <code id="hmlMatrixEntryIncrement" type="statement" init="hmlMatrixDef"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/><identifier value="_d_"/>
   _a_(_b_,_c_) += _d_;
 </code>

 <code id="hmlGetMatrixInvEntry" type="expression" init="hmlMatrixDef"><identifier value="_a_"/><identifier value="_b_"/><identifier value="_c_"/>
   _a_(_b_,_c_)
 </code>

 <code id="hmlShortCircuit" type="statement"><identifier value="_cur_"/><identifier value="_new_"/>
   _cur_ = _new_;
 </code>

 <code id="hmlFWBW" type="statement"><identifier value="_cur_"/><identifier value="_new_"/>
   _cur_ += _new_;
 </code>

 <code id="hmlViterbi" type="statement" init="hmlMaxDef"><identifier value="_cur_"/><identifier value="_new_"/>
   hmmocMaxInPlace( _cur_, _new_ );
 </code>

 <code id="hmlSampleInitVec" type="statement">
  <identifier value="_vec_"/>
  <identifier value="_val_"/>
  static const int _vec_[] = {_val_};
 </code>

 <code id="hmlSampleInit" type="statement">
  <identifier value="_tmpintvec_"/>
  <identifier value="_start_"/>
  <identifier value="_end_"/>
  _tmpintvec_[0] = _start_;
  while (_tmpintvec_[0] != _end_) {
    _tmpintvec_[1] = 2;
 </code>

 <code id="hmlSampleSwitch" type="statement">
   <identifier value="_tmpintvec_"/>
    switch (_tmpintvec_[0]) {
      default:
 </code>

 <code id="hmlGetStateFuncDef" type="statement" init="includemap">
  <identifier value="_hmmid_"/>
  <identifier value="_twocol_"/>
  <identifier value="_iState_"/>
  <identifier value="_poslist_"/>
  <identifier value="_poslist2_"/>
  <![CDATA[
  #ifndef __hmmid__twocol_getprobdefined_
  #define __hmmid__twocol_getprobdefined_

  const string& _hmmid__twocol_DPTable::getTransitionId(int id) { return id>=0 && id<__hmmid_transNum ? __hmmid_transitionId[id] : __hmmid_empty; }
  const string& _hmmid__twocol_DPTable::getEmissionId(int id) { return id>=0 && id<__hmmid_emitNum ? __hmmid_emissionId[id] : __hmmid_empty; }
  const string& _hmmid__twocol_DPTable::getStateId(int id) { return id>=0 && id<__hmmid_stateNum ? __hmmid_stateId[id] : __hmmid_empty; }
  const string& _hmmid__twocol_DPTable::getOutputId(int id) { return id>=0 && id<__hmmid_outputNum ? __hmmid_outputId[id] : __hmmid_empty; }
  int _hmmid__twocol_DPTable::getId(const string& sId)
  {
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
      pmId = new map<string,int>();
      for (int i=0;i<__hmmid_stateNum;i++) {
        (*pmId)[__hmmid_stateId[i]] = i;         // add state identifiers
      }
      for (int i=0; i<__hmmid_emitNum; i++) {
        (*pmId)[__hmmid_emissionId[i]] = i;      // add emission identifiers
      }
      for (int i=0; i<__hmmid_transNum; i++) {  
        (*pmId)[__hmmid_transitionId[i]] = i;    // add transition identifiers
      }
      for (int i=0; i<__hmmid_outputNum; i++) {
        (*pmId)[__hmmid_outputId[i]] = i;        // finally, add output identifiers
      }
      bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
      if (sId == "_cleanup_") {
        delete pmId;
      } else {
        cout << "_hmmid__twocol_DPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
      }
      return -1;
    }
    return iter->second;
  }
  /* line */
  _extreal_ _hmmid__twocol_DPTable::getProb(const string sState _poslist_) const
  {
    return getProb(getId(sState) _poslist2_);
  }
  /* line */
  _extreal_ _hmmid__twocol_DPTable::getProb(int _iState_ _poslist_) const
  {
  ]]>
 </code>

 <code id="hmlGetStateFuncEnd" type="statement">
  } // switch
  } // DPTable...::getProb(int,...)
  #endif // ...getprobdefined_
 </code>

 <code id="hmlGetStateSwitch" type="statement">
   <identifier value="_array_"/>
   <identifier value="_stateid_"/>
     switch (_array_[_stateid_]) {
      default:
       return 0.0;
  </code>

 <code id="hmlGetStateDefault" type="statement">
    return 0.0;
 </code>

 <code id="hmlSampleCase" type="statement">
  <identifier value="_state_"/>
  break;
  case _state_:
 </code>

 <code id="hmlSampleTransition" type="statement">
  <identifier value="_tmpintvec_"/>
  <identifier value="_tmpvec_"/>
  <identifier value="_totprob_"/>
  <identifier value="_offset_"/>
  <identifier value="_prob_"/>
  <identifier value="_trans_"/>
  _tmpvec_[_tmpintvec_[1]] = _totprob_;
  _tmpvec_[_tmpintvec_[1]+_offset_] = _prob_;
  _tmpintvec_[_tmpintvec_[1]++] = _trans_;
 </code>

 <code id="hmlSampleSwitchEnd" type="statement">
  break;
  }
 </code>

 <code id="hmlViterbiProcess" type="statement">
  <identifier value="_tmpintvec_"/>
  <identifier value="_tmpvec_"/>
  <![CDATA[

  _tmpvec_[0] = 0.0;
  for (int i=2; i<_tmpintvec_[1]; i++) {
    if (_tmpvec_[i]>_tmpvec_[0]) {
      _tmpvec_[0]=_tmpvec_[i];
      _tmpintvec_[0] = i;
    }
  }

  ]]>
 </code>

 <code id="hmlSampleProcess" type="statement" init="includestdlib">
  <identifier value="_tmpintvec_"/>
  <identifier value="_tmpvec_"/>
  <![CDATA[

  _tmpvec_[0] = _tmpvec_[1] = 0.0;
  for (int i=2; i<_tmpintvec_[1]; i++) {
    _tmpvec_[0] += _tmpvec_[i];
  }
  _tmpvec_[0] *= (random() / (double)RAND_MAX);
  _tmpintvec_[0] = 1;
  while (_tmpvec_[0]>=_tmpvec_[1] && ++_tmpintvec_[0]<_tmpintvec_[1]) {
    _tmpvec_[1] += _tmpvec_[_tmpintvec_[0]];
  }
  if (_tmpintvec_[0]==_tmpintvec_[1]) {
    cerr << "Error in sampler -- zero probabilities?" << endl;
    exit(1);
  }

 ]]>
 </code>

 <code id="hmlSampleNextPos" type="statement">
  <identifier value="_tmpintvec_"/>
  <identifier value="_pos_"/>
  <identifier value="_posvec_"/>
  _pos_ += _posvec_[_tmpintvec_[_tmpintvec_[0]]];
 </code>

 <code id="hmlSampleEnd" type="statement">
  <identifier value="_tmpintvec_"/>
  <identifier value="_statevec_"/>
  _tmpintvec_[0] = _statevec_[_tmpintvec_[_tmpintvec_[0]]];
  }
 </code>

 <code id="hmlHMMIdentifiers" type="statement">
  <identifier value="_hmmid_"/>
  <identifier value="_states_"/>
  <identifier value="_emissions_"/>
  <identifier value="_transitions_"/>
  <identifier value="_fromstates_"/>
  <identifier value="_tostates_"/>
  <identifier value="_probs_"/>
  <identifier value="_emits_"/>
  <identifier value="_outputs_"/>
  <![CDATA[

#ifndef __hmmid__defined_identifiers_
#define __hmmid__defined_identifiers_

const string __hmmid_stateId[] = {_states_};
const string __hmmid_emissionId[] = {_emissions_};
const string __hmmid_transitionId[] = {_transitions_};
const string __hmmid_transF[] = {_fromstates_};
const string __hmmid_transT[] = {_tostates_};
const string __hmmid_transP[] = {_probs_};
const string __hmmid_transE[] = {_emits_};
const string __hmmid_outputId[] = {_outputs_};
const string __hmmid_empty = "";

  ]]>
 </code>

 <code id="hmlHMMIdentifiers2" type="statement">
  <identifier value="_hmmid_"/>
  <identifier value="_numstates_"/>
  <identifier value="_numemissions_"/>
  <identifier value="_numtransitions_"/>
  <identifier value="_numoutputs_"/>
  <![CDATA[

const int __hmmid_stateNum = _numstates_;
const int __hmmid_emitNum = _numemissions_;
const int __hmmid_transNum = _numtransitions_;
const int __hmmid_outputNum = _numoutputs_;

#endif // __hmmid__defined_identifiers_

  ]]>
 </code>



 <!-- The following is split into 5 parts, to go after each other, leaving definition, declaration, init and exit code to be inserted -->

 <code id="hmlDPTableA" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[

/* line */
#ifndef __hmmid__table_defined_
#define __hmmid__table_defined_

// Here go the state memory clique typedefs:

  ]]>
 </code>
 <code id="hmlDPTableB" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[

/* line */
class _hmmid_DPTable {
public:
  // If true, this class' destructor will delete the DP arrays
  bool isInCharge;
  // Pointers to arrays containing ids of states and transitions
  const string* const stateId;
  const string* const emissionId;
  const string* const transitionId;
  const string* const transitionFrom;
  const string* const transitionTo;
  const string* const transitionProb;
  const string* const transitionEmit;
  const string* const outputId;
  // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:

  ]]>
 </code>
 <code id="hmlDPTableC" type="statement">
  <identifier value="_hmmid_"/>
  <identifier value="_twocol_"/>
  <identifier value="_lengths_"/>
  <identifier value="_iState_"/>
  <identifier value="_poslist_"/>
  <![CDATA[

  // Member functions:
public:
  // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
  _hmmid__twocol_DPTable(_lengths_);
  ~_hmmid__twocol_DPTable();
  // returns probability from DP table, given position and int or string state identifier
  _extreal_ getProb(int _iState_ _poslist_) const;
  _extreal_ getProb(const string sState _poslist_) const;
  // converts string identifier (for state, transition or emission) into integer id
  static int getId(const string& sState);
  static const string& getTransitionId(int id);
  static const string& getEmissionId(int id);
  static const string& getStateId(int id);
  static const string& getOutputId(int id);
  static void _cleanup() { getId("_cleanup_"); }
};

#ifndef __hmmid__realtype_defined_
#define __hmmid__realtype_defined_
// give a name to the real type used for this HMM
typedef _extreal_ _hmmid_Real;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef _shortreal_ _hmmid_ShortReal;
#endif // __hmmid__realtype_defined_

#endif // __hmmid__twocol__table_defined_

 ]]>
 </code>

 <code id="hmlDPTableD" type="statement">
  <identifier value="_hmmid_"/>
  <identifier value="_twocol_"/>
  <identifier value="_lengths_"/>
  <![CDATA[

  #ifndef __hmmid__twocol__table_member_defined_
  #define __hmmid__twocol__table_member_defined_

const extern string __hmmid_stateId[];
const extern string __hmmid_emissionId[];
const extern string __hmmid_transitionId[];
const extern string __hmmid_transF[];
const extern string __hmmid_transT[];
const extern string __hmmid_transP[];
const extern string __hmmid_transE[];
const extern string __hmmid_outputId[];
const extern string __hmmid_empty;
const extern int __hmmid_stateNum;
const extern int __hmmid_emitNum;
const extern int __hmmid_transNum;
const extern int __hmmid_outputNum;

  _hmmid__twocol_DPTable::_hmmid__twocol_DPTable(_lengths_) : isInCharge(true), stateId(__hmmid_stateId), emissionId(__hmmid_emissionId), transitionId(__hmmid_transitionId), transitionFrom(__hmmid_transF), transitionTo(__hmmid_transT), transitionProb(__hmmid_transP), transitionEmit(__hmmid_transE), outputId(__hmmid_outputId) {
    // init code:
  ]]>
 </code>

 <code id="hmlDPTableE" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[
  }
  /* line */
  _hmmid_DPTable::~_hmmid_DPTable() {
    if (!isInCharge) {
      // make sure data does not get deleted:
  ]]>
 </code>

 <code id="hmlDPTableF" type="statement">
  <identifier value="_hmmid_"/>
  <![CDATA[

    } // if(!isInCharge)
  } // destructor
  #endif // __hmmid__table_member_defined_
  ]]>
 </code>

 <code id="hmlDPTableInit" type="statement"><identifier value="_hmmid_"/><identifier value="_lengths_"/>
   _hmmid_DPTable dp_lengths_;
 </code>

 <code id="hmlDPTableInput" type="statement"><identifier value="_hmmid_"/>
   _hmmid_DPTable dp(*pInTable);
   // make sure tables don't get deleted
   dp.isInCharge = false;
 </code>

 <code id="hmlSecondaryDPTableInput" type="statement"><identifier value="_hmmid_"/>
   _hmmid_DPTable dp2(*pInTable);
   // make sure tables don't get deleted
   dp2.isInCharge = false;
 </code>

 <code id="hmlDPTableParameter" type="expression"><identifier value="_hmmid_"/>
   _hmmid_DPTable** ppOutTable
 </code>

 <code id="hmlDPTableParameterInput" type="expression"><identifier value="_hmmid_"/>
   _hmmid_DPTable* pInTable
 </code>

 <code id="hmlDPTableReturn" type="statement"><identifier value="_hmmid_"/>
   *ppOutTable = new _hmmid_DPTable(dp);
   // make sure tables don't get deleted
   dp.isInCharge = false;
 </code>

 <code id="hmlDPTableLenDecl" type="statement"><identifier value="_len_"/>
    int _len_;
 </code>

 <code id="hmlDPTableLenInit" type="statement"><identifier value="_len_"/>
    this->_len_ = _len_;
 </code>

 <!--
 <code id="hmlViterbiDeclaration" type="statement">
  <identifier value="_name_"/>
  <identifier value="_pars_"/>
  <![CDATA[
   /* line */
   Path& _name_(_pars_);

  ]]>
 </code>

 <code id="hmlViterbiCall" type="statement">
  <identifier value="_name_"/>
  <identifier value="_hmmid_"/>
  <identifier value="_pars_"/>
  <identifier value="_callpars_"/>
  <![CDATA[

   /* line */
   /* line */
   Path& _name_(_pars_) {
     _hmmid_DPTable* pTable;
     _name__recurse(_callpars_, &pTable);
     return _name__trace(_callpars_, pTable);
   }

  ]]>
 </code>
 -->

 <code id="includeVector" type="statement" where="header-includes">
   <![CDATA[

     /* line */
     #include <vector>
     #include <iostream>
     #include <string>
     #include <algorithm>

     using std::vector;
     using std::cout;
     using std::string;

   ]]>
 </code>

 <code id="includestdlib" type="statement" where="header-includes">
   <![CDATA[

     /* line */
     #include <stdlib.h>
     #include <math.h>

   ]]>
 </code>
 
 <code id="includemap" type="statement" where="header-includes">
   <![CDATA[
    
     /* line */
     #include <map>

     using std::map;

   ]]>
 </code>


 <code id="hmlSimplePathDecl" type="statement" where="classdefinitions" init="includeVector">
    <![CDATA[

#IFNDEF _PATH_CLASS_DEFINED_
#DEFINE _PATH_CLASS_DEFINED_

class Path {
  //protected:
public:
  vector<int> transitions;
public:
  unsigned int size() const {                             // Number of transitions in path
    return transitions.size(); 
  }
  int transition(int i) const {                           // i-th transition
    return transitions[i]; 
  }
  virtual double prob(int) const = 0;                  // i-th transition*emission probability:
  virtual const vector<int>& emission(int) const = 0;  // i-th emission vector
  virtual int fromState(int) const = 0;                // State at from-end of i-th transition
  virtual int toState(int) const = 0;                  // State at to-end of i-th transition
  virtual int nextFrom(int) const = 0;                 // index of next sibling, -1 if no more (always -1 for simple paths)
  virtual int nextTo(int) const = 0;                   // index of child (always i+1 for simple paths), or -1 if no more
  virtual ~Path() {} 
};

ostream& operator<<(ostream& os, const Path& p);

class SimplePath: public Path {
public:
  vector<double> probs;
  vector<vector<int> > emissions;
  vector<int> froms;
  vector<int> tos;
public:
  void addEdge(int transition, double prob, vector<int>& emission, int from, int to);
  double prob(int index) const;
  int nextFrom(int index) const;
  int nextTo(int index) const;
  const vector<int>& emission(int index) const;
  int fromState(int index) const;
  int toState(int index) const;
  void reverse();
};  

#ENDIF // _PATH_CLASS_DEFINED_

 ]]>
 </code>



 <code id="hmlSimplePath" type="statement" where="subroutines" init="hmlSimplePathDecl">
   <![CDATA[

ostream& operator<<(ostream& os, const Path& p)
{
  for (unsigned int i=0; i<p.size(); i++) {
    os << p.fromState(i) << "--{";
    for (unsigned int j=0; j<p.emission(i).size(); j++) {
      if (j) os<<",";
      os<<p.emission(i)[j];
    }
    os<<"};"<<p.prob(i)<<"-->"<<p.toState(i)<<endl;
  }
  return os;
}

void SimplePath::addEdge(int tr, double p, vector<int>& e, int f, int t) {
    transitions.push_back(tr);
    probs.push_back(p);
    emissions.push_back(e);
    froms.push_back(f);
    tos.push_back(t);
  }

void SimplePath::reverse() 
{
    std::reverse(transitions.begin(),transitions.end());
    std::reverse(probs.begin(),probs.end());
    std::reverse(emissions.begin(),emissions.end());
    std::reverse(froms.begin(),froms.end());
    std::reverse(tos.begin(),tos.end());
}

double SimplePath::prob(int i) const {
    return probs[i];
  }

int SimplePath::nextFrom(int i) const {
    if (i+1 < (int)transitions.size())
      return i+1;
    else
      return -1;
  }

int SimplePath::nextTo(int i) const {
    return -1;
  }

const vector<int>& SimplePath::emission(int i) const {
    return emissions[i];
  }

int SimplePath::fromState(int i) const {
    return froms[i];
  }

int SimplePath::toState(int i) const {
    return tos[i];
  }

  ]]>
 </code>


 <code id="hmlSimplePathAlloc" type="statement" init="hmlSimplePath">
 <![CDATA[
  SimplePath* pPath = new SimplePath();
  vector<int> emit;
 ]]>
 </code>
 <code id="hmlSimplePathAddA" type="statement" init="includeVector">
  <identifier value="_dim_"/>
  emit.resize(_dim_);
 </code>
 <code id="hmlSimplePathAddB" type="statement">
  <identifier value="_idx_"/>
  <identifier value="_vec_"/>
  <identifier value="_tmpintvec_"/>
  emit[_idx_] = _vec_[_tmpintvec_[_tmpintvec_[0]]];
 </code>
 <code id="hmlSimplePathAddC" type="statement" init="hmlSimplePathAlloc">
  <identifier value="_tmpintvec_"/>
  <identifier value="_tmpvec_"/>
  <identifier value="_offset_"/>
  <identifier value="_fromtable_"/>
  <identifier value="_totable_"/>
  <![CDATA[
  pPath->addEdge(_tmpintvec_[_tmpintvec_[0]],_tmpvec_[_tmpintvec_[0]+_offset_],emit,_fromtable_[_tmpintvec_[_tmpintvec_[0]]],_totable_[_tmpintvec_[_tmpintvec_[0]]]);
  ]]>
 </code>
 <code id="hmlSimplePathReturn" type="statement">
  return *pPath;
 </code>



 <code id="hmlMatrixDef" type="statement" init="includeVector" where="declarations">
   <![CDATA[

/* line */
/* line */
#IFNDEF _HMMOCMATRIX_CLASS_DEFINED_
#DEFINE _HMMOCMATRIX_CLASS_DEFINED_

class hmmocMatrix {
protected:
  vector<double> ivCoeff;
public:
  int iDim;
public:
  // Default, empty matrix
  hmmocMatrix() {
    iDim = 0;
    ivCoeff.resize(0);
  }
  // Create matrix
  hmmocMatrix( int iDimen ) {
    iDim = iDimen;
    ivCoeff.resize( iDim*iDim );
  }
  // Unit matrix init
  void unitMatrix() {
    for (int i=0; i<iDim; i++)
      for (int j=0; j<iDim; j++)
        (*this)(i,j) = (i==j);
  }
  // Copy matrix constructor
  hmmocMatrix( const hmmocMatrix& iM ) {
    this->assign( iM );
  }
  inline hmmocMatrix& assign( const hmmocMatrix& iM ) {
    iDim = iM.iDim;
    ivCoeff.resize( iDim*iDim );
    for (int i=0; i<iDim*iDim; i++) {
      ivCoeff[i] = iM.ivCoeff[i];
    }
    return *this;
  }
  inline double operator()(const int i, const int j) const { 
    if ((i<0)||(j<0)||(i>=iDim)||(j>=iDim)) {
      cerr << "hmmocMatrix::operator(): Out of range!" << endl;
      exit(1);
    } 
    return ivCoeff[i*iDim+j]; 
  }
  inline double& operator()(const int i, const int j) { 
    if ((i<0)||(j<0)||(i>=iDim)||(j>=iDim)) {
      cerr << "hmmocMatrix::operator(): Out of range!" << endl;
      exit(1);
    } 
    return ivCoeff[i*iDim+j]; 
  }
};

#ENDIF // _HMMOCMATRIX_CLASS_DEFINED_

   ]]>
 </code>  



 <code id="hmlMaxDef" type="statement" where="subroutines">
  <![CDATA[
    /* line */
    _extreal_ hmmocMax(_extreal_ i, _extreal_ j) { return i>j ? i : j; }
    void hmmocMaxInPlace(_extreal_& i, _extreal_ j) { if (i<j) i=j; }
  ]]>
 </code>



<code id="hmlSelfRefViterbiA" type="statement">
   <identifier value="_vec_"/>
   <identifier value="_intvec_"/>
   <identifier value="_dim_"/>
   <![CDATA[

  for (int i=0; i<_dim_; i++) {
    _intvec_[i] = 0;
  }
  for (int i=1; i<_dim_; i++) {
    _vec_[_dim_]=0.0;
    for (int j=0; j<_dim_; j++) {
      if (!_intvec_[j] && _vec_[j] > _vec_[_dim_]) {
        _vec_[_dim_] = _vec_[j];
        _intvec_[_dim_] = j;
      }
      _intvec_[_intvec_[_dim_]] = 1;
      switch (_intvec_[_dim_]) {
        default:  // dummy    
    
    ]]></code>


<code id="hmlSelfRefViterbiB" type="statement">
   <identifier value="_num_"/>
   <![CDATA[      

      break;
      case _num_:    

   ]]></code>

<code id="hmlSelfRefViterbiC" type="statement" init="hmlMaxDef">
<identifier value="_vec_"/><identifier value="_new_"/><identifier value="_num_"/><identifier value="_trans_"/>
     hmmocMaxInPlace(_vec_[_new_], _vec_[_num_] * _trans_);    
 </code>


<code id="hmlSelfRefViterbiD" type="statement">
   <![CDATA[        
        break;     
      }
    }
  }
  
  ]]>
</code>

     



 <code id="hmlMatrixInverse" type="statement" where="subroutines" init="hmlMatrixDef">
   <![CDATA[

/* Matrix inverse, adapted from Numerical Recipes (Press et al.) by Yun Song, 26/6/2002 */

inline void hmmocSwap( double& i, double& j ) {
  double tmp = i;
  i = j;
  j = tmp;
}

void hmmocMatrixInverse( const hmmocMatrix& iM, hmmocMatrix& iInv )
{
  int iDimen = iM.iDim;
  int id1, id2;
  int icol=0, irow=0;
  double big, fElt, pivinv;

  // copy contents of iM into matrix iInv
  iInv.assign( iM );

  vector<int> indxc(iDimen);  // piv column index
  vector<int> indxr(iDimen);  // piv row index
  vector<int> ipiv(iDimen);

  for (id1=0; id1 < iDimen; id1++) 
    ipiv[id1]=0;  
  for (int i=0; i < iDimen; i++) {     //reduce over columns
    big = 0.0;
    for (int j=0; j < iDimen; j++) {   //search for pivots
      if(ipiv[j] != 1) {
	for(int k=0; k < iDimen; k++) {
	  if(ipiv[k] == 0) {
	    if(fabs(iInv(j,k)) >= big) {
	      big=fabs(iInv(j,k));
	      irow=j;
	      icol=k;
	    }
	  } 
          else if (ipiv[k] > 1) {
	    cerr<< "Singular Matrix-1" <<endl;
	    exit(1);
	  }
	}
      }
    }
    ++(ipiv[icol]);
    if (irow != icol) {
      for (int l=0;l<iDimen;l++) {   //exchange rows
        hmmocSwap( iInv(irow,l), iInv(icol,l) );
      }
    }
    indxr[i]=irow;
    indxc[i]=icol;
    // divide pivot row by pivot elt
    if (iInv(icol,icol) == 0.0) {
      cerr<< "Singular Matrix-2" << endl;
      exit(1);
    }
    pivinv=1.0/iInv(icol,icol);
    iInv(icol,icol)=1.0;
    for (id1=0;id1<iDimen;id1++) 
      iInv(icol,id1) *= pivinv;
    for (id1=0;id1<iDimen;id1++) {  // reduce non-pivot rows
      if (id1 != icol) {
	fElt=iInv(id1,icol);
	iInv(id1,icol)=0.0;
	for (id2=0;id2<iDimen;id2++) {
	  iInv(id1,id2) -= iInv(icol,id2)*fElt;
	}
      }
    }
  }
  for (int l=iDimen-1;l>=0;l--) {
    if (indxr[l] != indxc[l]) {
      for (int k=0;k<iDimen;k++) { //exchange columns in backward order
        hmmocSwap( iInv(k,indxr[l] ), iInv(k,indxc[l]) );
      }
    }
  }
}

   ]]></code>




<code id="extendedreal" type="statement" where="header-includes">
<![CDATA[

#include "algebras.h"

]]>
</code>




<code id="hmlBanding" type="statement" where="classdefinitions">
</code>

<code id="hmlBandingIdentifier" type="expression" value="position"/>

<code id="hmlForwardBandingLoop" type="statement" init="hmlBanding">
<identifier value="_dim_"/><identifier value="_banding_"/><identifier value="_slowcoord_"/>
<![CDATA[

{
  Banding<_dim_>::Position& position = _banding_.forwardIterator();
  bool bLastSlowCoordInited = false;
  int iLastSlowCoord = -1;  
  do {
      if (bLastSlowCoordInited) {
        if (iLastSlowCoord > _slowcoord_) {
          cout << "WARNING: Banding (forward): Slowest coordinate should be nondecreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
        }
      } else {
        bLastSlowCoordInited = true;
      }
      iLastSlowCoord = _slowcoord_;

]]>
</code>

<code id="hmlForwardBandingLoopEnd" type="statement" init="hmlBanding">
<identifier value="_dim_"/><identifier value="_banding_"/>
<![CDATA[

  } while (_banding_.hasNextForward());
}

]]>
</code>



<code id="hmlBackwardBandingLoop" type="statement" init="hmlBanding">
<identifier value="_dim_"/><identifier value="_banding_"/><identifier value="_slowcoord_"/>
<![CDATA[

{
  Banding<_dim_>::Position& position = _banding_.backwardIterator();
  int iCheckSlowCoordTraversal = -1;  
  do {
      if (iCheckSlowCoordTraversal != -1 && iCheckSlowCoordTraversal < _slowcoord_) {
          cout << "WARNING: Banding (backward): Slowest coordinate be nonincreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
      }
      iCheckSlowCoordTraversal = _slowcoord_;

]]>
</code>

<code id="hmlBackwardBandingLoopEnd" type="statement" init="hmlBanding">
<identifier value="_dim_"/><identifier value="_banding_"/>
<![CDATA[

  } while (_banding_.hasNextBackward());
}

]]>
</code>


<!-- Warn if the banding iterator goes outside the allowed range -->

<code id="hmlOutOfRangeWarning" type="statement">
<identifier value="_banding_"/>
<![CDATA[

  _banding_.warning();

]]>
</code>



<code id="hmlInitSlowCoord" type="statement">
 int iPrevSlowCoord;
</code>


<code id="hmlResetSlowCoord" init="hmlInitSlowCoord" type="statement">
  iPrevSlowCoord = -1;
</code>




<code id="hmlClearFoldedMemoryA" type="statement" init="hmlInitSlowCoord">
<identifier value="_slowcoord_"/>
<identifier value="_block_"/>
<![CDATA[

]]>
</code>



<code id="hmlClearFoldedMemoryB" type="statement" init="hmlInitSlowCoord">
<identifier value="_slowcoord_"/>
<![CDATA[

  iPrevSlowCoord = _slowcoord_;

]]>
</code>

<code id="hmlClearFoldedMemoryPerTable" type="statement" init="hmlInitSlowCoord">
<identifier value="_slowcoord_"/>
<identifier value="_block_"/>
<![CDATA[

  if (iPrevSlowCoord != -1 && iPrevSlowCoord != _slowcoord_) {
    dp.StateMemory_block_.clear(_slowcoord_);
  }

]]>
</code>



<!-- default dynamic programming tables -->

<code id="DPTable" type="expression" init="dptable_header">
DPTable
</code>

<code id="SparseDPTable" type="expression" init="dptable_header">
SparseDPTable
</code>

<code id="dptable_header" type="statement" where="header-includes">
<![CDATA[
#include "dptables.h"
]]>
</code>


<!-- return a value -->

<code id="hmlReturnCode1" type="statement">
<identifier value="_temp_"/>
<identifier value="_value_"/>

    _temp_ = _value_;

</code>


<code id="hmlReturnCode2" type="statement">
<identifier value="_temp_"/>

    return _temp_;

</code>




</snippets>
  
