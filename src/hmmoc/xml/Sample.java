/*
 *    This file is part of HMMoC 1.3, a hidden Markov model compiler.
 *    Copyright (C) 2007 by Gerton Lunter, Oxford University.
 *
 *    HMMoC is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    HMMOC is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with HMMoC; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
\*/
package hmmoc.xml;

import org.jdom.*;
import java.util.*;

import hmmoc.util.CompileUtils;
import hmmoc.util.IntVec;
import hmmoc.code.Book;
import hmmoc.code.StateCode;
import hmmoc.code.TransitionCode;
import hmmoc.code.RangeCode;
import hmmoc.code.PositionCode;
import hmmoc.code.EmissionCode;
import hmmoc.code.Generator;
import hmmoc.code.TemporariesCode;
import hmmoc.code.SymbolCode;


public class Sample {
	
	String id;
	
	HMM hmm;
	String hmmid;
	TreeMap objects;
	boolean viterbi;
	boolean hasInput;        // if false, no DP table is input (only for sampler)
	String name;
	String params;           // used by calling routine to make function that binds Viterbi recursion and tracer
	
	
	public Sample( Element elem, TreeMap idRef, TreeMap objs ) {
		
		id = elem.getAttributeValue("id");
		
		hmm = CompileUtils.getHMM(elem,idRef,objs);
		
		hasInput = true;
		
		if (elem.getName().equals("viterbi")) {
			viterbi = true;
		} else {
			viterbi = false;
			if (hmm.numOutputs == 0)
				hasInput = false;
		}
		
		if (elem.getAttributeValue("name") != null) {
			name = elem.getAttributeValue("name");
		}
		
		// This should reflect HMM and output type -- ignore output dependence for now
		hmmid = hmm.id;
		
		objects = objs;
		
	}
	
	
	Code getCode( String id ) {
		
		return Generator.getCode(id,objects);
		
	}
	
	
	public void generate( Book book, String language) {
		
		// Class definition of DP table is not generated; either it is already generated by FW/BW/ViterbiDP,
		// or it is not required (in the case of sampling with no given outputs)
		
		book.openLinearScopeAtInit("dptableclassdef",5,"header-classdef");
		
		book.openLinearScopeAtInit("dptableclassmemberdef",3,"subroutines");
		
		book.openScope("function");
		
		book.openScope("define");
		
		book.openScope("declare");
		
		// Create code for numerical temporary variables
		TemporariesCode temporariesCode = new TemporariesCode( hmm, book, "declare" );
		temporariesCode.getVectorEntry( 2*hmm.maxOutDegree+2 );
		temporariesCode.getIntVecEntry( hmm.maxOutDegree+2 );
		
		// Declare state memory, and copy input DP table
		book.openScope("init");
		
		// Declare and initialize transitions
		TransitionCode transitionCode = new TransitionCode( hmm, book, objects, temporariesCode, "declare", "init", true );
		
		// Declare emissions
		EmissionCode emissionCode = new EmissionCode( hmm, book, objects, true, true, "declare", true );
		
		book.openScope("position");
		
		// Get position variables
		PositionCode positionCode = new PositionCode( hmm, book, objects );
		positionCode.init( hmm.startState.range, true, "position", null );
		
		// Make translation tables
		int num = hmm.transitions.length;
		Transition[] transitionArr = new Transition[num];
		for (int i=0; i<num; i++) {
			transitionArr[i] = (Transition)objects.get( hmm.transitions[i] );
		}
		ArrayList intListT = new ArrayList( num );
		ArrayList intListF = new ArrayList( num );
		for (int i=0; i<num; i++) {
			intListT.add( new Integer( ((State)objects.get( transitionArr[i].to )).globalNumber ) );
			intListF.add( new Integer( ((State)objects.get( transitionArr[i].from )).globalNumber ) );
		}
		book.addInitText("init", getCode("hmlSampleInitVec").bind("stateTable",Generator.makeCommaList(intListT)) );
		book.addInitText("init", getCode("hmlSampleInitVec").bind("stateFromTable",Generator.makeCommaList(intListF)) );
		String[] posVecName = new String[hmm.numOutputs];
		for (int i=0; i<hmm.numOutputs; i++) {
			posVecName[i] = positionCode.getPos(i)+"Table";
			for (int j=0; j<num; j++)
				intListT.set(j, new Integer( ((Emission)objects.get( transitionArr[j].emission )).outputVec.v[i] ) );
			book.addInitText("init", getCode("hmlSampleInitVec").bind(posVecName[i],Generator.makeCommaList(intListT)) );
		}
		
		String tmpVec = temporariesCode.getVectorName();
		String tmpIntVec = temporariesCode.getIntVecName();
		
		book.add(getCode("hmlSampleInit").bind(tmpIntVec,
                Integer.toString(hmm.startState.globalNumber),
                Integer.toString(hmm.endState.globalNumber) ) );
		
		book.openScope("symbol");
		
		// Declare symbols (use default range)
		SymbolCode symbolCode = new SymbolCode( hmm, book, objects, "declare", "init" );
		RangeCode rangeCode = new RangeCode(hmm);
		symbolCode.init( positionCode, rangeCode, "symbol" );
		
		// ??????? Should this be 'false'?????
		StateCode.initDPInput("init", hmmid, book, objects, false );
		
		// Loop over all receiving blocks
		for (int blockCount = 0; blockCount < hmm.sortedBlocks.length; blockCount += 1) {
			
			Clique clique = (Clique)objects.get(hmm.blocks[blockCount]);
			
			book.openScope("statevector");
			
			StateCode stateCode = new StateCode(hmm, book, objects, clique, "declare", true, false, false, true );
			
			// Generate class definitions only once.  Access dummy state to emit code
			if (blockCount == 0) {
				stateCode.initClass(positionCode, "dptableclassdef", "dptableclassmemberdef", hmm.id );
			}
			
			// Dummy access, to make sure all definitions get output
			IntVec dummyVec = new IntVec(hmm.numOutputs);
			stateCode.initToEmission(positionCode, temporariesCode, dummyVec, "dptableclassdef", "dptableclassmemberdef","init","statevector");
			stateCode.getState( "", null, 1, false );
			
			// Loop over all emission vectors for all forward transitions (ie going to this clique)
			IntVec[] emissions = clique.getEmissionVectors(true, objects);
			for (int emIdx=0; emIdx<emissions.length; emIdx++) {
				
				book.openScope("emission");
				
				// Now check range
				RangeCode range = new RangeCode( hmm.range, book );
				IntVec offset = new IntVec(emissions[emIdx]);
				range.checkRange( offset, clique.range, positionCode, "emission" );
				
				// Get code to access states in new clique & position
				IntVec negOffset = new IntVec(offset).negate();
				stateCode.initToEmission(positionCode, temporariesCode, negOffset, "dptableclassdef", "dptableclassmemberdef","init","emission");
				
				//book.add( new Text( "/* doing emission "+emissions[emIdx]+" */\n") );
				
				emissionCode.init( emissions[emIdx], clique, symbolCode, temporariesCode, positionCode, "emission" );
				
				// Emit switch statement
				book.add( getCode("hmlSampleSwitch").bind(tmpIntVec) );
				
				// Loop over all originating states, that go to current to-clique (in forward direction)
				State[] origStates = clique.getToStates(emissions[emIdx], clique, objects);
				for (int orIdx=0; orIdx<origStates.length; orIdx++) {
					
					// Output "case" line
					book.add( getCode("hmlSampleCase").bind(Integer.toString(origStates[orIdx].globalNumber) ) );
					
					// Loop over all target states
					State[] targetStates = clique.getFromStates(emissions[emIdx], clique, origStates[orIdx], objects);
					
					for (int tarIdx=0; tarIdx<targetStates.length; tarIdx++) {
						
						String tarStateRef;
						if (hasInput) {
							tarStateRef = stateCode.getState( targetStates[tarIdx], null, 1 );
						} else {
							tarStateRef = "1.0";
						}
						
						Transition[] transitions = clique.getFromToTransitions(emissions[emIdx], clique,
								origStates[orIdx], 
								targetStates[tarIdx], 
								objects );
						
						for (int transIdx=0; transIdx<transitions.length; transIdx++) {
							
							Emission em = (Emission)objects.get( transitions[transIdx].emission  );
							String emRef = emissionCode.getText( em, positionCode, symbolCode, temporariesCode, "emission" );
							String transRef = transitionCode.getText( transitions[transIdx], book, symbolCode, positionCode, 
									emissions[emIdx], true, true );
							
							// Store transition*emission probability separately in tmpvec, at offset (hmm.maxOutDegree) from beginning
							book.add( getCode("hmlSampleTransition").bind( tmpIntVec, 
									tmpVec,
									transRef + "*" + emRef + "*" + tarStateRef,
                                    Integer.toString(hmm.maxOutDegree),
									transRef + "*" + emRef,
                                    Integer.toString(transitions[transIdx].number) ) );
						}
					}
				}
				
				book.add( getCode("hmlSampleSwitchEnd").getText() );
				
				book.closeScope("emission");
				
			}
			
			book.closeScope("statevector");
			
		}
		
		// Next, process the possible transitions from this state
		book.add( getCode( viterbi ? "hmlViterbiProcess" : "hmlSampleProcess" ).bind(tmpIntVec,tmpVec) );
		
		// Add bead to string!  
		book.add( getCode( "hmlSimplePathAddA" ).bind(Integer.toString(hmm.numOutputs) ) );
		for (int i=0; i<hmm.numOutputs; i++) {
			book.add( getCode( "hmlSimplePathAddB" ).bind(Integer.toString(i), posVecName[i], tmpIntVec) );
		}
		book.add( getCode( "hmlSimplePathAddC" ).bind( tmpIntVec, tmpVec, Integer.toString(hmm.maxOutDegree), "stateFromTable", "stateTable" ) );
		
		// Go to next state/position
		for (int i=0; i<hmm.numOutputs; i++) {
			book.add( getCode("hmlSampleNextPos").bind( tmpIntVec, positionCode.getPos(i), posVecName[i] ) );
		}
		book.add( getCode( "hmlSampleEnd" ).bind(tmpIntVec, "stateTable") );
		
		// Call static member function that emits all necessary initialization code to the init-block of the "declare" scope
		Code.emitInitCode(objects, book, "", "declare");
		
		// Build parameter string
		String pars = Code.getParameters(objects);
		params = pars;
		pars = Code.addParameter(pars, getCode("hmlDPTableParameterInput").bind(hmmid).toString() );
		
		symbolCode.exit();
		
		book.closeScope("symbol");
		
		book.closeScope("position");
		
		book.closeScope("init");
		
		// Before closing declare scope, emit the necessary declarations and definitions
		emissionCode.exit();
		temporariesCode.exit();
		
		// Compute return value
		book.add( getCode("hmlSimplePathReturn").getText() );
		
		book.closeScope("declare");
		
		book.closeScope("define");
		
		// Finally, build function definition
		book.addInitText( "function", getCode("hmlSampleFuncStart").bind(name,pars));
		book.addExitText( "function", getCode("hmlSampleFuncEnd").getText() );
		book.addInitText( "header-funcdecl", getCode("hmlSampleFuncDeclaration").bind(name,pars));
		
		book.closeScope("function");
		
	}
}
